\documentclass[a4paper,USenglish,cleveref, autoref, thm-restate]{lipics-v2021}
%This is a template for producing LIPIcs articles. 
%See lipics-v2021-authors-guidelines.pdf for further information.
%for A4 paper format use option "a4paper", for US-letter use option "letterpaper"
%for british hyphenation rules use option "UKenglish", for american hyphenation rules use option "USenglish"
%for section-numbered lemmas etc., use "numberwithinsect"
%for enabling cleveref support, use "cleveref"
%for enabling autoref support, use "autoref"
%for anonymousing the authors (e.g. for double-blind review), add "anonymous"
%for enabling thm-restate support, use "thm-restate"
%for enabling a two-column layout for the author/affilation part (only applicable for > 6 authors), use "authorcolumns"
%for producing a PDF according the PDF/A standard, add "pdfa"

%\pdfoutput=1 %uncomment to ensure pdflatex processing (mandatatory e.g. to submit to arXiv)
%\hideLIPIcs  %uncomment to remove references to LIPIcs series (logo, DOI, ...), e.g. when preparing a pre-final version to be uploaded to arXiv or another public repository

%\graphicspath{{./graphics/}}%helpful if your graphic files are in another directory

\bibliographystyle{plainurl}% the mandatory bibstyle

\title{Mechanized Undecidability of Higher-order beta-Matching} %TODO Please add

%\titlerunning{Dummy short title} %TODO optional, please use if title is longer than one line

\author{Andrej Dudenhefner}{TU Dortmund University, Germany}{andrej.dudenhefner@cs.tu-dortmund.de}{https://orcid.org/0000-0003-1104-444X}{}
%TODO mandatory, please use full name; only 1 author per \author macro; first two parameters are mandatory, other parameters can be empty. Please provide at least the name of the affiliation and the country. The full address is optional. Use additional curly braces to indicate the correct name splitting when the last name consists of multiple name parts.

\authorrunning{A. Dudenhefner} %TODO mandatory. First: Use abbreviated first/middle names. Second (only in severe cases): Use first author plus 'et al.'

\Copyright{Andrej Dudenhefner} %TODO mandatory, please use full first names. LIPIcs license is "CC-BY";  http://creativecommons.org/licenses/by/3.0/

\ccsdesc[500]{Theory of computation~Lambda calculus} %TODO mandatory: Please choose ACM 2012 classifications from https://dl.acm.org/ccs/ccs_flat.cfm 

\keywords{lambda-calculus, simple types, undecidability, higher-order matching, mechanization, Coq} %TODO mandatory; please add comma-separated list of keywords

\category{} %optional, e.g. invited paper

\relatedversion{} %optional, e.g. full version hosted on arXiv, HAL, or other respository/website
%\relatedversiondetails[linktext={opt. text shown instead of the URL}, cite=DBLP:books/mk/GrayR93]{Classification (e.g. Full Version, Extended Version, Previous Version}{URL to related version} %linktext and cite are optional

\supplementdetails[subcategory={Source Code},linktext={github/uds-psl/coq-library-undecidability}]{Software}{https://github.com/uds-psl/coq-library-undecidability/} %linktext, cite, and subcategory are optional
%\supplement{}%optional, e.g. related research data, source code, ... hosted on a repository like zenodo, figshare, GitHub, ...
%\supplementdetails[linktext={opt. text shown instead of the URL}, cite=DBLP:books/mk/GrayR93, subcategory={Description, Subcategory}, swhid={Software Heritage Identifier}]{General Classification (e.g. Software, Dataset, Model, ...)}{URL to related version} %linktext, cite, and subcategory are optional

%\funding{(Optional) general funding statement \dots}%optional, to capture a funding statement, which applies to all authors. Please enter author specific funding statements as fifth argument of the \author macro.

%\acknowledgements{I want to thank \dots}%optional

%\nolinenumbers %uncomment to disable line numbering

%Editor-only macros:: begin (do not touch as author)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\EventEditors{John Q. Open and Joan R. Access}
\EventNoEds{2}
\EventLongTitle{42nd Conference on Very Important Topics (CVIT 2016)}
\EventShortTitle{CVIT 2016}
\EventAcronym{CVIT}
\EventYear{2016}
\EventDate{December 24--27, 2016}
\EventLocation{Little Whinging, United Kingdom}
\EventLogo{}
\SeriesVolume{42}
\ArticleNo{23}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage[a-1b]{pdfx}
\usepackage{wasysym} %\brokenvert
\usepackage{csquotes} %\enquote{} macro
\usepackage{bussproofs}
\usepackage{mathtools}
\usepackage[dvipsnames]{xcolor}

\theoremstyle{definition}
\newtheorem{problem}[theorem]{Problem}

%%%%%%%%%%%%%%%%%% specific %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\DeclareMathOperator{\id}{id}
\DeclareMathOperator{\length}{length}
\DeclareMathOperator{\depth}{depth}

%%%%%%%%%%%%%%%%%%%%%%%% stylized symbols %%%%<%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\bbB}{\mathbb{B}}
\newcommand{\bbC}{\mathbb{C}}
\newcommand{\bbN}{\mathbb{N}}
\newcommand{\bbT}{\mathbb{T}}
\newcommand{\bbS}{\mathbb{S}}
\newcommand{\bbV}{\mathbb{V}}
\newcommand{\bbZ}{\mathbb{Z}}
\newcommand{\calA}{\mathcal{A}}
\newcommand{\calC}{\mathcal{C}}
\newcommand{\calD}{\mathcal{D}}
\newcommand{\calF}{\mathcal{F}}
\newcommand{\calM}{\mathcal{M}}
\newcommand{\calQ}{\mathcal{Q}}
\newcommand{\calR}{\mathcal{R}}
\newcommand{\calT}{\mathcal{T}}
\newcommand{\calU}{\mathcal{U}}

\newcommand{\frakR}{\mathfrak{R}}

\newcommand{\0}{\mathbf{0}}
\newcommand{\1}{\mathbf{1}}
\newcommand{\2}{\mathbf{2}}
\newcommand{\K}{\mathbf{K}}

\newcommand{\case}[2]{\ensuremath{\textnormal{\textbf{case }} #1 \textnormal{\textbf{ of }} \langle #2 \rangle}}
\newcommand{\caseelse}[3]{\ensuremath{\textnormal{\textbf{case }} {#1} \textnormal{\textbf{ of }} \langle #3 \mid #2 \rangle}}
\newcommand{\ite}[4]{\ensuremath{\textbf{if } #1 \textbf{ is } #2 \textbf{ then } #3 \textbf{ else } #4}}
\newcommand{\itb}[3]{\ensuremath{\textbf{if } #1 \textbf{ is } #2 \textbf{ then } #3}}

\newcommand{\coq}[1]{\textnormal{[\href{https://github.com/uds-psl/coq-library-undecidability/blob/70dfc56f33a6e4835281044e68aa68279989047e/theories/LambdaCalculus/Reductions/SSTS01\_to\_HOMbeta.v\##1}{\raisebox{-0.2em}{\includegraphics[width=0.6em]{coq-logo.pdf}}}]}}
\newcommand{\coqextra}[1]{\textnormal{[\href{https://github.com/uds-psl/coq-library-undecidability/blob/70dfc56f33a6e4835281044e68aa68279989047e/theories/#1}{\raisebox{-0.2em}{\includegraphics[width=0.6em]{coq-logo.pdf}}}]}}

\newcommand{\isep}{-0.4em}

%%%%%%%%%%%%%%%%%%%%%%%%% Abbreviations etc. %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\ga}{\ensuremath{\iota}}

\begin{document}

\maketitle

%TODO mandatory: add short abstract of the document
\begin{abstract}
Higher-order beta-matching is the following decision problem: given two simply typed lambda-terms, can the first term be instantiated to be beta-equivalent to the second term?
This problem was formulated by Huet in the 1970s and shown undecidable by Loader in 2003.
The particular proof is by reduction from an ad-hoc definability problem for finite models of the simply-typed lambda-calculus.

The present work presents a novel undecidability proof of higher-order beta-matching, in an effort to verify this result by means of a proof assistant in full detail.
Rather than starting from lambda-definability, the presented proof encodes a restricted form of string rewriting as higher-order beta-matching.
The particular approach is similar to Urzyczyn's undecidability result for intersection type inhabitation.

The presented approach has several benefits.
First, the proof is simpler to verify in full detail due to the simple form of rewriting systems, which serve as a starting point.
Second, undecidability of the considered problem in string rewriting is already certified using the Coq proof assistant.
Building upon the existing work, we obtain a certified many-one reduction from the (Turing machine) Halting Problem to Higher-order $\beta$-Matching.
Third, the presented approach identifies a uniform construction which shows undecidability of higher-order beta-matching, lambda-definability, and intersection type inhabitation.

The presented undecidability proof is mechanized in the Coq proof assistant and contributed to the existing Coq library of undecidability proofs.
\end{abstract}

\lstset{
comment=[l]{(*},
basicstyle=\ttfamily\footnotesize,
keywordstyle=\color{blue},
morekeywords={Inductive,Type,Theorem,Definition,exists,fun},
commentstyle=\color{OliveGreen},
backgroundcolor=\color{yellow!5},
framerule=0.4pt,
frame=single,
inputencoding=utf8,
extendedchars=false,}

\setlength{\abovedisplayskip}{3pt}
\setlength{\belowdisplayskip}{3pt}

\section{Introduction}

\begin{remark}
Loaders proof introduces some additional machinery
\begin{itemize}
\item \emph{myopic} $\lambda\bot$-terms and \emph{myopic} order
\item characterization of $1$-lifts and $7$-lifts by \emph{checker} $\lambda\bot$-terms
\item characterization of finite models by $(7+1)$-lifted terms\qedhere
\end{itemize}
\end{remark}

\subparagraph*{Paper organization} The present work is structured as follows: 
\begin{description}
\item[Section~\ref{sec:prelim}:] Preliminaries for the simply typed $\lambda$-calculus, Higher-order $\beta$-Matching, and simple semi-Thue systems (including the undecidable Problem $\0^+ \Rightarrow^*_\frakR \1^+$).
\item[Section~\ref{sec:loader}:] Examples on constraints TODO.
\item[Section~\ref{sec:undec}:] Reduction from Problem $\0^+ \Rightarrow^*_\frakR \1^+$ to Higher-order $\beta$-Matching.
\item[Section~\ref{sec:mech}:] Overview over the mechanization in the Coq proof assistant.
\item[Section~\ref{sec:concl}:] Concluding remarks.
\end{description}

\newpage

\section{Preliminaries}\label{sec:prelim}
In the present section we fix preliminaries and basic notation, following standard literature~\cite{Barendregt13book}.
\paragraph*{Higher-order $\beta$-Matching in the Simply Typed $\lambda$-Calculus}

The syntax of untyped $\lambda$-terms is given in the following Definition~\ref{def:terms}.

\begin{definition}[$\lambda$-Terms\;\coqextra{L/L.v\#L8}]\label{def:terms}
\[
M, N ::= x \mid M \, N \mid \lambda x.M
\]
\end{definition}
Substitution of the term variable $x$ in the term $M$ by the term $N$ is denoted $M[x := N]$.

\begin{definition}[$\beta$-Reduction\;\coqextra{LambdaCalculus/Lambda.v\#L53}]
The relation $\to_\beta$ on terms is the contextual closure of $(\lambda x.M)\,N \to_\beta M[x := N]$.
\end{definition}
The $\beta$-equivalence relation $=_\beta$ is the reflexive, transitive, symmetric closure of $\to_\beta$.

In the simply typed $\lambda$-calculus we may assign to a term $M$ a simple type $\tau$ in type environment $\Gamma$, written $\Gamma \vdash M : \tau$.
Similarly to prior work~\cite{Loader03}, one ground atom $\ga$ in the construction of simple types suffices for the negative result in the present work.
Definition~\ref{def:stlc} contains the rules (Var), ($\to$I), and ($\to$E) of the simple type system.

\begin{definition}[Simple Types with Ground Atom $\ga$\;\coqextra{LambdaCalculus/HOMatching.v\#L23}]
\[
\sigma, \tau ::= \ga \mid \sigma \to \tau
\]
\end{definition}

\begin{definition}[Type Environments]
\[
\Gamma ::= \{x_1 : \sigma_1, \ldots, x_n : \sigma_n\}
\]
\end{definition}

\begin{definition}[Simple Type System\;\coqextra{LambdaCalculus/HOMatching.v\#L31}]\label{def:stlc}
~\\[4pt]
\begin{tabular}{ccc}
{\RightLabel{\textnormal{(Var)}}
\AxiomC{$(x : \sigma) \in \Gamma$}
\UnaryInfC{$\Gamma \vdash x : \sigma$}
\DisplayProof}
&
{\RightLabel{\textnormal{($\to$I)}}
\AxiomC{$\Gamma, x : \sigma \vdash M : \tau$}
\UnaryInfC{$\Gamma \vdash \lambda x.M : \sigma \to \tau$}
\DisplayProof}
&
{\RightLabel{\textnormal{($\to$E)}}
\AxiomC{$\Gamma \vdash M : \sigma \to \tau$}
\AxiomC{$\Gamma \vdash N : \sigma$}
\BinaryInfC{$\Gamma \vdash M\,N : \tau$}
\DisplayProof}
\end{tabular}
\end{definition}

Higher-order $\beta$-Matching is the following typed unification problem, for which only one side is subject to instantiation. 

\begin{problem}[Higher-order $\beta$-Matching (${F}\,\mathsf{X} = N$)\;\coqextra{LambdaCalculus/HOMatching.v\#L37}]\label{prb:hom}
Given terms $F, N$ and simple types~$\sigma, \tau$ such that $\emptyset \vdash F : \sigma \to \tau$ and $\emptyset \vdash N : \tau$, is there a term $M$ such that $\emptyset \vdash M : \sigma$ and $F\,M =_\beta N$?
\end{problem}

Undecidability of Higher-order $\beta$-Matching is shown by Loader~\cite{Loader03} using a reduction from a variant of $\lambda$-definability.

\begin{theorem}[{\cite[Theorem~5.5]{Loader03}}]
Higher-order $\beta$-Matching is undecidable.
\end{theorem}

TODO the follo9wing examples discuss properties of HOM and techniques

The following Example~\ref{xmp:hom} illustrates a positive instance of Higher-order $\beta$-Matching.

\begin{example}\label{xmp:hom}
Consider the terms $F := \lambda x.\lambda y.x\,y\,(\lambda z.z)$ and $N := \lambda y.y$.\\
We have $\emptyset \vdash F : (\ga \to (\ga \to \ga) \to \ga) \to (\ga \to \ga)$ and $\emptyset \vdash N : \ga \to \ga$.

The instance ${F}\,\mathsf{X} = N$ of Higher-order $\beta$-Matching is solvable, including the solution $M := \lambda u.\lambda f.f\,u$.
In particular, we have the following two properties:
\begin{itemize}
\item $\emptyset \vdash M : \ga \to (\ga \to \ga) \to \ga$
\item $F\,M =_\beta \lambda y.(\lambda u.\lambda f.f\,u)\,y\,(\lambda z.z) =_\beta \lambda y.(\lambda z.z)\,y =_\beta N$
\end{itemize}
\end{example}


\paragraph*{Simple Semi-Thue Systems}

A simple semi-Thue system (Definition~\ref{def:ssts}) is a rewriting system of restricted shape, introduced by Urzyczyn~\cite{Urzyczyn09} in order to show undecidability of intersection type inhabitation.

\begin{definition}[Simple Semi-Thue System\;\coqextra{StringRewriting/SSTS.v\#L23}]\label{def:ssts}
A semi-Thue system $\frakR$ over an alphabet $\calA$ is \emph{simple}, if each rule has the form $ab \Rightarrow cd$ for $a,b,c,d \in \calA$.
\end{definition}

For arbitrary simple semi-Thue systems it is undecidable whether some non-empty sequence of $\0$s can be transformed into a sequence of $\1$s.

\begin{problem}[$\0^+ \Rightarrow^*_\frakR \1^+$\;\coqextra{StringRewriting/SSTS.v\#L37}]\label{prb:ssts01}
Given a simple semi-Thue system $\frakR$, does $\0^n \Rightarrow^*_\frakR \1^n$ hold for some $n > 0$?
\end{problem}

\begin{theorem}[{\cite[Lemma~3.3\;\coqextra{StringRewriting/SSTS\_undec.v\#L21}]{DudenhefnerR19}}]\label{thm:ssts_undec}
Problem $\0^+ \Rightarrow^*_\frakR \1^+$ is undecidable.
\end{theorem}

The following Example~\ref{xmp:ssts} illustrates a positive instance of Problem $\0^+ \Rightarrow^*_\frakR \1^+$.

\begin{example}\label{xmp:ssts}
Let $\frakR  := \{\0\0 \Rightarrow \2\2, \0\2 \Rightarrow \1\1, \2\0 \Rightarrow \1\1\}$ be a simple semi-Thue system over the alphabet $\{\0,\1,\2\}$.
We have $\0\0\0\0 \Rightarrow_\frakR \0\2\2\0 \Rightarrow_\frakR \1\1\2\0 \Rightarrow_\frakR \1\1\1\1$. As a side note, we have $\0^n \;{\not\Rightarrow}_\frakR^*\; \1^n$ for $n \in \{1, 2, 3\}$.
\end{example}

\begin{remark}
Problem $\0^+ \Rightarrow^*_\frakR \1^+$ used as a starting point in a refinement~\cite[Lemma~4.4]{DudenhefnerR19} of Urzyczyn's undecidability result for intersection type inhabitation~\cite{Urzyczyn09}.
Undecidability of Problem $\0^+ \Rightarrow^*_\frakR \1^+$ is mechanized as part of Coq Library of Undecidability Proofs~\cite{CLUP20}, making it a good starting point for further mechanized undecidability results.
\end{remark}

\newpage

\section{Shape Constraint and Loader}\label{sec:loader}
Before we present an alternative approach to undecidability of higher-order $\beta$-matching, let us first get familiar with tools at our disposal.

\paragraph*{Finite Models}

\begin{definition}[Finite Model]
Fix a finite set $\calM_\ga$, $\calM_{\sigma \to \tau}$ is the finite set of all functions from $\calM_\sigma$ to $\calM_\tau$.
\end{definition}

We use tabular notation for families of finite functions in a given finite model, illustrated by the following examples.

\setlength{\arraycolsep}{1pt}

\begin{example}
Fix the finite model $\calM$ with $\calM_\ga = \{1, 2\}$.
The family ${\small\left(\begin{array}{c}
1 \mapsto 2\\
2 \mapsto 1
\end{array}\right)} \subseteq \calM_{\ga \to \ga}$ contains exactly one finite function $f \in \calM_{\ga \to \ga}$ where $f(1) = 2$, $f(2) = 1$.
\end{example}

\begin{example}
Fix the finite model $\calM$ with $\calM_\ga = \{1, 2, 3\}$.
The family ${\small\left(\begin{array}{c}
1 \mapsto 2\\
2 \mapsto 3
\end{array}\right)} \subseteq \calM_{\ga \to \ga}$ contains exactly three distinct finite functions $f \in \calM_{\ga \to \ga}$ where $f(1) = 2$, $f(2) = 3$, and $f(3) \in \{1, 2, 3\}$.
\end{example}

\begin{example}\label{xmp:fin-model}
Fix the finite model $\calM$ with $\calM_\ga = \{1, 2, 3\}$. The family $\left({\small\left(\begin{array}{c}
1 \mapsto 2\\
2 \mapsto 3
\end{array}\right)} \mapsto (1 \mapsto 3)\right)$ contains finite functions $f \in \calM_{(\ga \to \ga) \to \ga \to \ga}$ such that $f(g)(1) = 3$ for any $g \in {\small\left(\begin{array}{c}
1 \mapsto 2\\
2 \mapsto 3
\end{array}\right)}$.

As a side note, there is a $\lambda$-definable member of $\left({\small\left(\begin{array}{c}
1 \mapsto 2\\
2 \mapsto 3
\end{array}\right)} \mapsto (1 \mapsto 3)\right)$ realized by the $\lambda$-term $\lambda f.\lambda x.f\,(f\,x)$.
\end{example}

Two examples.
First, in which there is only a semantic constraint and where the solution is wrong and arbitrary syntax.

\begin{example}\label{xmp:ad-hoc}
Consider the finite model $\calM$ from Example~\ref{xmp:fin-model} with $\calM_\ga = \{1, 2, 3\}$ together with the family $\calF = \left({\small\left(\begin{array}{c}
1 \mapsto 2\\
2 \mapsto 3
\end{array}\right)} \mapsto (1 \mapsto 3)\right)$ of finite functions.

Let us realize elements of the set $\{1, 2, 3\}$ by projections $\pi_1 := \lambda xyz.x$, $\pi_2 := \lambda xyz.y$, and $\pi_3 := \lambda xyz.z$ respectively.
For the term $G := \lambda h.\lambda x y z.h\,y\,z\,x$ we have
\[G\,\pi_1 \twoheadrightarrow_\beta \pi_2 \text{ and } G\,\pi_2 \twoheadrightarrow_\beta \pi_3\]
Therefore, $G$ realizes a member of ${\small\left(\begin{array}{c}
1 \mapsto 2\\
2 \mapsto 3
\end{array}\right)}$.
Consider the matching constraint $\mathsf{X}\,G\,\pi_1 =_\beta \pi_3$.
Any term which realizes a member of the family $\calF$ solves the above constraint.
For instance, we have $\big(\lambda f.\lambda t.f\,(f\,t)\big)\,G\,\pi_1 \twoheadrightarrow_\beta \pi_3$.

However, the converse is not true.
One obvious solution to the above constraint is the term $\lambda f.\lambda t.\pi_3$ because $\big(\lambda f.\lambda t.\pi_3\big)\,G\,\pi_1
\twoheadrightarrow_\beta \pi_3$.
Another solution to the above constraint is the term $\lambda f.\lambda t.\lambda x y z.t\,z\,z\,z$ because $\big(\lambda f.\lambda t.\lambda x y z.t\,z\,z\,z\big)\,G\,\pi_1
\twoheadrightarrow_\beta \lambda x y z.\pi_1\,z\,z\,z \twoheadrightarrow_\beta \pi_3$.
Both solutions construct realizers of the set $\{1, 2, 3\}$ via explicit abstraction $\lambda x y z.[\ldots]$.
\end{example}

In the simply typed setting an additional constraint suffices in order to exclude above ad-hoc solutions, illustrated in the following Example~\ref{xmp:no-ad-hoc}.

\begin{example}\label{xmp:no-ad-hoc}
Consider a solution $M$ in normal form for matching constraint $\mathsf{X}\,(\lambda x.x)\,u =_\beta u$ where $u$ is a term variable.
Additionally, assume that $\emptyset \vdash M : (\sigma \to \sigma) \to \sigma \to \sigma$ for some simple type $\sigma$.
By case analysis on $M$ we have that $M = \lambda f.\lambda t.N$ for some term $N$ in normal form which is not an abstraction.
Furthermore, $\{f : \sigma \to \sigma, t : \sigma\} \vdash N : \sigma$ and $N[f := \lambda x.x, t := u] \twoheadrightarrow_\beta u$.
By induction on the size of $N$ and case analysis we have that $N = t$ or $N = f\,(\ldots(f\,t)\ldots)$.

As a result, any solution to both matching constraints $\mathsf{X}\,(\lambda h.\lambda x y z.h\,y\,z\,x)\,\pi_1 =_\beta \pi_3$ and $\mathsf{X}\,(\lambda x.x)\,u =_\beta u$ realizes a member of the family $\left({\small\left(\begin{array}{c}
1 \mapsto 2\\
2 \mapsto 3
\end{array}\right)} \mapsto (1 \mapsto 3)\right)$.

Ad-hoc solutions such as $\lambda f.\lambda t.\pi_3$ or $\lambda f.\lambda t.\lambda x y z.t\,z\,z\,z$ from Example~\ref{xmp:ad-hoc} do not solve the constraint $\mathsf{X}\,(\lambda x.x)\,u =_\beta u$ because such solutions contain too many abstractions on the right-hand side.
\end{example}

\begin{remark}\label{rem:eta-break}
Example~\ref{xmp:no-ad-hoc} demonstrates that certain matching constraints restrict the number of abstractions in solutions.
However, in the presence of $\eta$-reduction this does not work, as shown below.
Considering $G := \lambda h.\lambda x y z.h\,y\,z\,x$, $\pi_1 = \lambda xyz.x$, $\pi_2 = \lambda xyz.y$, and $\pi_3 = \lambda xyz.z$ from Example~\ref{xmp:no-ad-hoc}, the term $M := \lambda g.\lambda h.\lambda xyz.h\,(g\,\pi_1 x\,z\,y)\,y\,z$ solves both constraints $\mathsf{X}\,G\,\pi_1 =_{\beta\eta} \pi_3$ and $\mathsf{X}\,(\lambda x.x)\,u =_{\beta\eta} u$ as follows:\\
$\arraycolsep=1.4pt\begin{array}[t]{lclcl}
M\,G\,\pi_1 &=& \big(\lambda g.\lambda h.\lambda xyz.h\,(g\,\pi_1 x\,z\,y)\,y\,z\big)\,G\,\pi_1
&\twoheadrightarrow_\beta& \lambda xyz.\pi_{1}\,(G\,\pi_1 x\,z\,y)\,y\,z\\
&\twoheadrightarrow_\beta& \lambda xyz.G\,\pi_1 x\,z\,y
&\twoheadrightarrow_\beta& \lambda xyz.\pi_1\,z\,y\,x \twoheadrightarrow_\beta \lambda xyz.z = \pi_{3}
\end{array}$\\
$\arraycolsep=1.4pt\begin{array}[t]{lclcl}
M\,(\lambda x.x)\,u &=& \big(\lambda g.\lambda h.\lambda xyz.h\,(g\,\pi_1 x\,z\,y)\,y\,z\big)\,(\lambda x.x)\,u
&\twoheadrightarrow_\beta& \lambda xyz.u\,((\lambda x.x)\,\pi_1 x\,z\,y)\,y\,z\\
&\twoheadrightarrow_\beta& \lambda xyz.u\,(\pi_1 x\,z\,y)\,y\,z &\twoheadrightarrow_\beta& \lambda xyz.u\,x\,y\,z \twoheadrightarrow_\eta u
\end{array}$\\
In addition, we have $\emptyset \vdash M : (\sigma \to \sigma) \to \sigma \to \sigma$ for $\sigma := \ga \to \ga \to \ga \to \ga$.
\end{remark}


The observation from the above Example~\ref{xmp:no-ad-hoc} is generalized by Loader to arbitrary families of finite functions.
This results in undecidability, of higher-order $\beta$-matching by reduction from (a variant of) $\lambda$-definability.

Loader's generalization is quite sophisticated, as it requires construction principles to restrict shapes of realizers of arbitrary finite functions of arbitrary order.
In the present work, we focus on a fragment, which can be identified identified by Urzyczyn and Salvati et.al.
This leads to a simpler proof and a connection between undecidability of HOmachting, intersection type inhabitation, and lambda-definability.

\newpage


\begin{example}\label{xmp:ad-hoc}
Let us associate elements of the set $\{1, 2, 3\}$ with projections $\pi_1 := \lambda xyz.x$, $\pi_2 := \lambda xyz.y$, and $\pi_3 := \lambda xyz.z$ respectively.
For the term $G := \lambda h.\lambda x y z.h\,y\,z\,x$ we have
$G\,\pi_1 =_\beta \pi_2$, $G\,\pi_2 =_\beta \pi_3$, and $G\,\pi_3 =_\beta \pi_1$.
Therefore, $G$ realizes a finite function $f_G : \{1, 2, 3\} \to \{1, 2, 3\}$ with the function table {\small$\begin{tabular}{c|c|c}
1 & 2 & 3\\\hline
2 & 3 & 1
\end{tabular}$}.

Let $\kappa := \ga \to \ga \to \ga \to \ga$ be a simple type for which we have $\emptyset \vdash \pi_i : \kappa$ for $i \in \{1,2,3\}$.
Consider the instance $(\lambda t.t\,G\,\pi_1)\,\mathsf{X} = \pi_3$ where $\emptyset \vdash \lambda t.t\,G\,\pi_1 : ((\kappa \to \kappa) \to \kappa \to \kappa) \to \kappa$.\linebreak
A solution for this instance is $\lambda f.\lambda s.f\,(f\,s)$ for which we have $(\lambda t.t\,G\,\pi_1)\,(\lambda f.\lambda s.f\,(f\,s)) =_\beta \pi_3$.
This solution follows the intended \enquote{meaning} of the underlying representation, constructing the element $3$ via $f_G(f_G(1))$.
Another solution is $\lambda f.\lambda s.f\,(f\,(f\,(f\,(f\,s))))$, which utilizes $f_G(f_G(f_G(f_G(f_G(1))))) = 3$.

Unfortunately, there are solutions to the above matching instance which behave differently.
One such solution is $\lambda f.\lambda s.\pi_3$ for which we also have $(\lambda t.t\,G\,\pi_1)\,(\lambda f.\lambda s.\pi_3) =_\beta \pi_3$.
In this solution, the element $3$ is constructed \enquote{ad-hoc}, with no reference to the provided arguments.
Another solution is the term $\lambda f.\lambda s.\lambda x y z.f\,s\,z\,z\,z$.
This solution exploits the exact representation of elements via projections, disregarding the intended \enquote{meaning} of the underlying representation.
\end{example}

\begin{example}\label{xmp:no-ad-hoc}
Consider a term $M$ in normal form such that $M\,I\,u =_\beta u$ where $u$ is a term variable, and $\emptyset \vdash M : (\kappa \to \kappa) \to \kappa \to \kappa$.
By case analysis on $M$ we have that $M = \lambda f.\lambda s.N$ for some term $N$ in normal form.
Furthermore, $\{f : \kappa \to \kappa, s : \kappa\} \vdash N : \kappa$ and $N[f := \lambda x.x, s := u] =_\beta u$.
Therefore, the term $N$ is not an abstraction.
By induction on the size of $N$ and case analysis we have that $N = s$ or $N = f\,(\ldots(f\,s)\ldots)$.
\end{example}


\begin{example}\label{xmp:no-ad-hoc}
$F := \lambda t.\lambda r.r\,(t\,G\,\pi_1)\,(\lambda u.t\,I\,u)$ and $N := \lambda r.r\,\pi_3\,(\lambda u.u)$.

$F\,\mathsf{X} = N$.

$\emptyset \vdash F : ((\kappa \to \kappa) \to \kappa \to \kappa) \to (\kappa \to (\kappa \to \kappa) \to \ga) \to \ga$

$\emptyset \vdash N : (\kappa \to (\kappa \to \kappa) \to \ga) \to \ga$

The instance $F\,\mathsf{X} = N$ combines the matching instance from Example~\ref{xmp:ad-hoc} with the additional property from Example~\ref{xmp:no-ad-hoc}. 

Therefore, solutions such as $\lambda f.\lambda s.f\,(f\,s)$ and $\lambda f.\lambda s.f\,(f\,(f\,(f\,(f\,s))))$ from Example~\ref{xmp:ad-hoc} which follow the intended \enquote{meaning} of the underlying representation still solve $F\,\mathsf{X} = N$.

However, ad-hoc solutions such as $\lambda f.\lambda s.\pi_3$ or $\lambda f.\lambda s.\lambda x y z.f\,s\,z\,z\,z$ from Example~\ref{xmp:ad-hoc} do not solve $F\,\mathsf{X} = N$ because such solutions contain too many abstractions (cf.~Example~\ref{xmp:no-ad-hoc}).
\end{example}

The observation in above example can be made systema



\newpage

\section{Undecidability of Higher-order $\beta$-Matching}\label{sec:undec}
In this section we develop our main result (Theorem~\ref{thm:ssts_to_hom}): a reduction from the rewriting problem $\0^+ \Rightarrow_\mathfrak{R}^* \1^+$ to Higher-order $\beta$-Matching.

For the remainder of the section we fix the simple semi-Thue system $\frakR := \{R_1, \ldots, R_L\}$ with $L > 0$ rules over the finite alphabet $\{\0, \1, \2, \ldots, \mathbf{K}\}$.
Our approach is to construct simply typed terms which capture the two main aspects of the rewriting problem $\0^+ \Rightarrow_\mathfrak{R}^* \1^+$: the search for a sufficiently long starting sequence of $\0$s, and the individual rewriting steps to the resulting sequence of $\1$s.

The remainder of the present section is structured as follows.
First, we fix basic notation, encoding, and properties of the rewriting in the system $\frakR$.
Second, we constraint the shape of potential solutions for the constructed matching instance, similarly to Example~\ref{xmp:no-ad-hoc}.
Third, for solutions of restricted shape we capture the functional properties of the rewriting problem $\0^+ \Rightarrow_\mathfrak{R}^* \1^+$.

\subsection*{Notation}

We introduce four additional symbols in extended alphabet $\calA := \{\0, \1, \ldots, \mathbf{K}\} \cup \{\$, \bullet, \top, \bot\}$.
We represent an alphabet symbol $i \in \calA$ as the projection $\pi_i := \lambda s_\0 s_\1 \ldots s_\K s_\$ s_\bullet s_\top s_\bot.s_i$ typed by the simple type $\kappa := \underbracket{\ga \to \ldots \to \ga}_{|\calA|~\text{times}} \to \ga$.
For readability, we use the following $\textbf{case}$ notation to match individual symbols.

\begin{definition}[\textbf{case}]\label{def:case}
For $k \in \bbN$, distinct $i_1, \ldots, i_k \in \calA$, and terms $M_1, \ldots, M_k$:
\begin{align*}
\caseelse{x}{i_1 \mapsto M_1 \mid \ldots \mid i_k \mapsto M_k}{M} := &~x\,N_\0\,N_\1 \ldots N_\K\,N_\$\,N_\bullet\,N_\top\,N_\bot\\
&\text{ where } N_i = \begin{cases} M_j & \text{if } i = i_j\\M & \text{otherwise}\end{cases}
\end{align*}
\end{definition}
A particular term $\delta_i$ for $i \in \calA$, which we will use commonly is:
\[\delta_i := \lambda x.\lambda s_\0 s_\1 \ldots s_\K s_\$ s_\bullet s_\top s_\bot.\caseelse{x}{\top \mapsto s_i}{s_\bot}\]
We have $\emptyset \vdash \delta_i : \kappa \to \kappa$, and the following Lemma~\ref{lem:delta} specifies the behavior of $\delta_i$.

\begin{lemma}\label{lem:delta}
For $i, j \in \calA$ such that $i \neq j$ we have
$\delta_i\,\pi_\top =_\beta \pi_i$ and $\delta_i\,\pi_j =_\beta \pi_\bot$.
\end{lemma}

As is usual, we define $I := \lambda x.x$, and for the remainder of the present section we assign the simple type $\kappa \to \kappa$ to each occurrence of $I$.

\subsection*{Syntactic Constrains}
We identify the shape of \enquote{well-formed} terms, suitable to represent rewriting.
In the following Definition~\ref{def:ring} terms in the set $\calQ_m$ capture consecutive rule application for a word of length $m + 1$, ending in the word $\1^{m+1}$ (represented by $z_\1 \in \calQ_m$).
The subterm $r_i\,p_j$ (and $r_i\,(\lambda w.p_j\,w)$) for $i \in \{1, \ldots, L\}$ and $j \in \{1, \ldots, m\}$ indicates an application of the rule $R_i$ at position $j$.
Additionally, terms in the set $\calR_m$ capture consecutive increase of word length starting with $m+1$, and initialization with $\0$s before rewriting (represented by $z_\0\,N\,M \in \calR_m$ for $M \in \calQ_m$).
Specifically, the subterm $(z_\star\,N\,(\lambda p_{m+1}.M))$ introduces an additional bound variable $p_{m+1}$ in order the argue about rule application at position $m+1$ in the longer word.
As a special case, terms in $\calR_1$ represent candidates witnessing an arbitrary expansion of a word of length $2$, followed by initialization with $\0$s, and consecutively rewritten to $\1$s.

\begin{definition}[Sets $\calQ_m$, $\calR_m$ of Terms]\label{def:ring}
For $m > 0$ let $\calQ_m$ and $\calR_m$ be the smallest sets of terms satisfying the following rules:
\begin{itemize}
\item $z_\1 \in \calQ_m$
\item If $M \in \calQ_m$ then $(r_i\,p_j\,M) \in \calQ_m$ for $i \in \{1, \ldots, L\}$ and $j \in \{1, \ldots, m\}$
\item If $M \in \calQ_m$ then $(r_i\,(\lambda w.p_j\,w)\,M) \in \calQ_m$ for $i \in \{1, \ldots, L\}$ and $j \in \{1, \ldots, m\}$
\item If $M \in \calQ_m$ then $(z_\0\,N\,M) \in \calR_m$
\item If $M \in \calR_{m+1}$ then $(z_\star\,N\,(\lambda p_{m+1}.M)) \in \calR_m$
\end{itemize}
\end{definition}

\begin{remark}\label{rem:R1}
Terms in $\calR_1$ are inspired by inhabitants in a refinement~\cite[Lemma~4.4]{DudenhefnerR19} of Urzyczyn's undecidability result for intersection type inhabitation~\cite{Urzyczyn09}.
\end{remark}

Free variables occurring in terms in $\calQ_m$ and $\calR_m$ are assigned simple types according to the following type environment $\Gamma_m$.

\begin{definition}[Type Environment $\Gamma_m$]\label{def:Gamma}
For $m > 0$ let
\begin{align*}
\Gamma_m &:= \{ \begin{aligned}[t]
&z_\1 : \kappa, z_\0 : (\kappa \to \kappa) \to \kappa \to \kappa, z_\star : (\kappa \to \kappa) \to ((\kappa \to \kappa) \to \kappa) \to \kappa,\\
&p_1 : \kappa \to \kappa, \ldots, p_m : \kappa \to \kappa,\\
&r_1 : (\kappa \to \kappa) \to \kappa \to \kappa, \ldots, r_L : (\kappa \to \kappa) \to \kappa \to \kappa\}
\end{aligned}
\end{align*}
\end{definition}

Similarly to Example~\ref{xmp:no-ad-hoc}, we formulate typed terms (Definition~\ref{def:H}) and $\beta$-equivalence constraints characterizing members of $\calQ_m$ (Lemma~\ref{lem:ring2}) and $\calR_m$ (Lemma~\ref{lem:ring1}).

\begin{definition}[Typed Terms $H_\star, H_\0, H_R$]\label{def:H}
\begin{align*}
H_\star := &\lambda h.\lambda g.\lambda s_\0 s_\1 \ldots s_\K s_\$ s_\bullet s_\top s_\bot. \caseelse{g\,\delta_\bullet}{\$ \mapsto s_\$}{s_\bot}\\
H_\0 := &\lambda h.\lambda x. \lambda s_\0 s_\1 \ldots s_\K s_\$ s_\bullet s_\top s_\bot.\caseelse{x}{\1 \mapsto s_\$}{s_\bot}\\
H_R := &\lambda h.\lambda x. \lambda s_\0 s_\1 \ldots s_\K s_\$ s_\bullet s_\top s_\bot.\caseelse{h\,\pi_\top}{\bullet \mapsto \caseelse{x}{\1 \mapsto s_\1}{s_\bot} }{s_\bot}
\end{align*}
\[
\emptyset \vdash H_\star : \Gamma_m(z_\star) \qquad\quad
\emptyset \vdash H_\0 : \Gamma_m(z_\0) \qquad\quad
\emptyset \vdash H_R : \Gamma_m(r_i) \text{ for } i \in \{1, \ldots, L\}
\]
\end{definition}

We introduce substitutions $S_F$ and $S_H$ acting on the term variables $\{z_\star, z_\1, z_\0, r_1, \ldots, r_L\}$, which occur in terms in $\calQ_m$ and $\calR_m$.

\begin{definition}[Substitutions $S_F$, $S_H$]\label{def:SF_SH}
~\\
$\begin{array}{lllllll}
S_F(z_\star) := \lambda h.\lambda g.g\,I &\quad&
S_F(z_\1) := u &\quad&
S_F(z_\0) := \lambda h.I &\quad&
S_F(r_j) := I \text{ for } j \in {1, \ldots L}\\
S_H(z_\star) := H_\star &&
S_H(z_\1) := \pi_\1 &&
S_H(z_\0) := H_\0 &&
S_H(r_j) := H_R \text{ for } j \in {1, \ldots L}
\end{array}$
\end{definition}

%(* x_R x_p M or x_R (\w.x_p w) M *)
%(* rule application term or concluding term *)
%Inductive ring2 (l : nat) : term -> Prop :=
%  | ring2_intro x y M : ring2 l M -> x < length rules -> y < l -> ring2 l (app (app (var (x + 3 + l)) (var y)) M)
%  | ring2_intro_eta x y M : ring2 l M -> x < length rules -> y < l -> ring2 l (app (app (var (x + 3 + l)) (lam (app (var (S y)) (var 0)))) M)
%  | ring2_fin : ring2 l (var (S l)).

\begin{lemma}\label{lem:ring2}
%Lemma construct_ring2 M m :
%  normal_form M ->
%  stlc (Gamma_A m) M A ->
%  steps (subst (sigma_F m) M) (var m) ->
%  steps (subst (sigma_H m) M) (pi one) ->
%  ring2 m M.
For $m > 0$, if a term $M$ is in normal form such that $\Gamma_m \vdash M : \kappa$,\\
$S_F(M)[p_1 {\,:=\,} I, \ldots, p_m {\,:=\,} I] =_\beta u$, and
$S_H(M)[p_1 := \delta_\bullet, \ldots, p_m := \delta_\bullet] =_\beta \pi_{\1}$,
then $M \in \calQ_m$.
\end{lemma}

\begin{proof}[Proof\;\coq{L1687}.]
Induction on the size of $M$ and case analysis of the normal form.
\end{proof}

%(* x_star N (\x_p.M) *)
%(* word expansion term or init rule application term *)
%Inductive ring1 (l : nat) : term -> Prop :=
%  | ring1_intro M N : ring1 (S l) M -> ring1 l (apps (var l) [N; lam M])
%  | ring1_init M N : ring2 l M -> ring1 l (apps (var (2 + l)) [N; M]).

\begin{lemma}\label{lem:ring1}
%Lemma construct_ring1 M m :
%  normal_form M ->
%  stlc (Gamma_A m) M A ->
%  steps (subst (sigma_F m) M) (var m) ->
%  steps (subst (sigma_H m) M) (pi dollar)  ->
%  ring1 m M.
For $m > 0$, if a term $M$ is in normal form such that $\Gamma_m \vdash M : \kappa$,\\
$S_F(M)[p_1 {\,:=\,} I, \ldots, p_m {\,:=\,} I] =_\beta u$, and
$S_H(M)[p_1 := \delta_\bullet, \ldots, p_m := \delta_\bullet] =_\beta \pi_{\$}$,
then $M \in \calR_m$.
\end{lemma}

\begin{proof}[Proof\;\coq{L1825}.]
Induction on the size of $M$, case analysis of the normal form, and Lemma~\ref{lem:ring2}.
\end{proof}

As a consequence of the above Lemma~\ref{lem:ring1}, the following Theorem~\ref{thm:shape} presents $\beta$-equivalence constraints which suffice to restrict the shape of terms under consideration.

\begin{theorem}\label{thm:shape}
%Lemma solution_shape (M : term) :
%  normal_form M ->
%  (* correctly typed closed term *)
%  stlc [] M (arrs (repeat A_0R (length rules + 1) ++ [A; A_star; arr A A]) A) ->
%  steps (apps M (repeat F_R (length rules) ++ [F_0; var 0; F_star; (lam (var 0))])) (var 0) ->
%  steps (apps M (repeat H_R (length rules) ++ [H_0; H_1; H_star; delta bullet])) (pi dollar) ->
%  exists N, M = lams (length rules + 4) N /\ ring1 1 N.
  
If a term $M$ is in normal form such that\\$\emptyset \vdash M : \Gamma_1(r_1) \to \cdots \to \Gamma_1(r_L) \to \Gamma_1(z_\0) \to \Gamma_1(z_\1) \to \Gamma_1(z_\star) \to \Gamma_1(p_1) \to \kappa$,\\
$M\,I \ldots I\,(\lambda h.I)\,u\,(\lambda h.\lambda g.g\,I)\,I =_\beta u$, and
$M\,H_R \ldots H_R\,H_\0\,\pi_\1\,H_\star\,\delta_\bullet =_\beta \pi_{\$}$,\\
then $M = \lambda r_1 \ldots r_L.\lambda z_\0 z_\1 z_\star p_1.N$ for some term $N$ such that $N \in \calR_1$.
\end{theorem}

\begin{proof}[Proof\;\coq{L1932}.]
Induction on the size of $M$, case analysis of the normal form, and Lemma~\ref{lem:ring1}.
\end{proof}

\newpage

\begin{example}\label{xmp:H}
Assume $\frakR = \{\0\0 \Rightarrow \2\2, \0\2 \Rightarrow \1\1, \2\0 \Rightarrow \1\1\}$ over the alphabet $\{\0,\1,\2\}$ from Example~\ref{xmp:ssts}.
Let $N := r_1\,p_2\,(r_2\,p_1\,(r_3\,p_3\,z_\1))$ and
$M := z_\star\,p_1\,(\lambda p_2.z_\star\,p_2\,(\lambda p_3.z_\0\,p_3\,N))$.
We have $N \in \calQ_3$ and $M \in \calR_1$.
In congruence with Theorem~\ref{thm:shape} we have:\\
$\begin{array}{ll}
(\lambda r_1 r_2 r_3.\lambda z_\0 z_\1 z_\star p_1.M)\,I\,I\,I\,(\lambda h.I)\,u\,(\lambda h.\lambda g.g\,I)\,I &=_\beta u\\
(\lambda r_1 r_2 r_3.\lambda z_\0 z_\1 z_\star p_1.M)\,H_R\,H_R\,H_R\,H_\0\,\pi_\1\,H_\star\,\delta_\bullet &=_\beta \pi_{\$}
\end{array}$

While Theorem~\ref{thm:shape} only establishes \enquote{well-formedness}, the term $M$ has an intended meaning.
Specifically, an initial word of length $2$ is expanded twice (using $z_\star$) to a word of length $4$ and initialized to $\0$s (using $z_\0$).
The introduced variables $p_2$ and $p_3$ are used to address positions in the longer word.
The intended meaning of $N$ is that the first rule (using $r_1$) is applied at position $2$ (using $p_2$), followed by the second rule at position $1$ and third rule at position $3$ accordingly.
The resulting word contains only $\1$s (indicated by $z_\1$).
Overall, this corresponds to $\0\0\0\0 \Rightarrow_\frakR \0\2\2\0 \Rightarrow_\frakR \1\1\2\0 \Rightarrow_\frakR \1\1\1\1$.

\end{example}

Having only \enquote{well-formed} terms to consider (cf. Example~\ref{xmp:ad-hoc} and Example~\ref{xmp:no-ad-hoc}), we can focus on the functional part of rewriting.

\subsection*{Semantic Constrains}

We formulate typed terms (Definition~\ref{def:G}) and $\beta$-equivalence constraints characterizing word expansion (Lemma~\ref{lem:R_ssts_sem}) and rewriting (Lemma~\ref{lem:Q_ssts_sem}).
The presented terms are programs which realize the intended meaning (Example~\ref{xmp:H}) of \enquote{well-formed} terms in $\calQ_m$ and $\calR_m$.
Specifically, $G_\star$ realizes word expansion, $G_\0$ realizes initialization with $\0$s, $G_{ab \Rightarrow cd}$ realizes rule application, and $G_j^i$ addresses position $i$ for rule application at position $j$.

\begin{definition}[Typed Terms $G_\star$, $G_\0$, $G_{ab \Rightarrow cd}$, $G_i^j$]
\label{def:G}
\begin{align*}
G_\star := &\lambda h.\lambda g.\lambda s_\0 s_\1 \ldots s_\K s_\$ s_\bullet s_\top s_\bot.\case{h\,\pi_\top}{s_\bot\\
&\hspace{1.0em} \mid \bullet \mapsto \caseelse{g\,\delta_\bullet}{\0 \mapsto s_\0 \mid \$ \mapsto \caseelse{g\,\delta_\0}{\1 \mapsto s_\$}{s_\bot}}{s_\bot}\\
&\hspace{1.0em} \mid \0 \mapsto \caseelse{g\,\delta_\1}{\0 \mapsto s_\1}{s_\bot}\\
&\hspace{1.0em} \mid \1 \mapsto \caseelse{g\,\delta_\bullet}{\0 \mapsto s_\0}{s_\bot}}\\
G_\0 := &\lambda h.\lambda x. \lambda s_\0 s_\1 \ldots s_\K s_\$ s_\bullet s_\top s_\bot.\case{h\,\pi_\top}{s_\bot\\
&\quad\mid \bullet \mapsto \caseelse{x}{\0 \mapsto s_\0 \mid \1 \mapsto s_\$}{s_\bot}\\
&\quad\mid\0 \mapsto \caseelse{x}{\0 \mapsto s_\1}{s_\bot}\\
&\quad\mid\1 \mapsto \caseelse{x}{\0 \mapsto s_\0 }{s_\bot}}\\
G_{ab \Rightarrow cd} := &\lambda h.\lambda x.\lambda s_\0 s_\1 \ldots s_\K s_\$ s_\bullet s_\top s_\bot.\case{h\,\pi_\top}{s_\bot\\
&\quad\mid\bullet \mapsto x\,s_\0\,s_\1\, \ldots s_\K\, s_\$\, s_\bullet\, s_\top\, s_\bot\\
&\quad\mid\0 \mapsto \caseelse{x}{d \mapsto s_b}{s_\bot}\\
&\quad\mid\1 \mapsto \caseelse{x}{c \mapsto s_a}{s_\bot}}\\
G_j^i := &\begin{cases}
\delta_\1 & \text{if } i = j\\
\delta_\0 & \text{if } i = j + 1\\
\delta_\bullet & \text{else}
\end{cases}
\end{align*}
\[\emptyset \vdash G_\star : \Gamma_m(z_\star) \qquad\quad
\emptyset \vdash G_\0 : \Gamma_m(z_\0) \qquad\quad
\emptyset \vdash G_{ab \to cd} : \Gamma_m(r_i) \text{ for } i \in \{1, \ldots, L\}\]
\end{definition}

Similarly to substitutions $S_F$ and $S_H$, we introduce the following substitution $S_G$.

\begin{definition}[Substitution $S_G$]\label{def:S_G}
\[S_G(z_\star) := G_\star \qquad
S_G(z_\1) := \pi_\1 \qquad
S_G(z_\0) := G_\0 \qquad
S_G(r_j) := G_{R_j} \text{ for } j \in {1, \ldots L}\]
\end{definition}

The following Example~\ref{xmp:rule} illustrates application of a term $G_{ab \Rightarrow cd}$.

\begin{example}\label{xmp:rule}
Consider the rule $bc \Rightarrow b'c'$ applied at position $2$ in order to rewrite the word $abcd$ to $ab'c'd$. Accordingly, we have:
\begin{description}
\item[Position $1$:] $G_{bc \Rightarrow b'c'}\,G_2^1\,\pi_a =_\beta \pi_a$
\item[Position $2$:] $G_{bc \Rightarrow b'c'}\,G_2^2\,\pi_{b'} =_\beta \pi_b$
\item[Position $3$:] $G_{bc \Rightarrow b'c'}\,G_2^3\,\pi_{c'} =_\beta \pi_c$
\item[Position $4$:] $G_{bc \Rightarrow b'c'}\,G_2^4\,\pi_d =_\beta \pi_d$
\end{description}
\end{example}

The above observation is generalized for terms in $\calQ_m$ in the following Lemma~\ref{lem:Q_ssts_sem}.

%  m > 0 ->
%  length v = S m ->
%  ring2 m M ->
%  stlc (Gamma_A m) M A ->
%  steps (subst (sigma_G m 0) M) (pi one) ->
%  Forall2 (fun i a => sym a < n /\ steps (subst (sigma_G m (S i)) M) (pi (sym a))) (seq 0 (S m)) v ->
%  SSTS.multi_step rules v (repeat 1 (S m)).

\begin{lemma}\label{lem:Q_ssts_sem}
For $m > 0$ let $a_1, \ldots, a_{m + 1} \in \{\0, \1, \ldots, \K\}$, and $M \in \calQ_m$. If $\Gamma_m \vdash M : \kappa$,\\
$S_G(M)[p_1 := G_1^0, \ldots, p_m := G_m^0] =_\beta \pi_\1$, and
$S_G(M)[p_1 := G_1^i, \ldots, p_m := G_m^i] =_\beta \pi_{a_i}$ for $i \in \{1, \ldots, m+1\}$,
then $a_1 \ldots a_{m + 1} \Rightarrow_\frakR^* \1^{m+1}$.
\end{lemma}

\begin{proof}[Proof\;\coq{L2106}.]
Induction on the size of $M$ and case analysis using Definition~\ref{def:ring}.
\end{proof}

The following Example~\ref{xmp:G_Q} builds upon the previous Example~\ref{xmp:H} and illustrates the intended meaning (rewriting $\0$s to $\1$s) of a \enquote{well-formed} example term in $\calQ_3$. %under the substitution $S_G$.

\begin{example}\label{xmp:G_Q}
Assume $\frakR = \{\0\0 \Rightarrow \2\2, \0\2 \Rightarrow \1\1, \2\0 \Rightarrow \1\1\}$ over the alphabet $\{\0,\1,\2\}$, and consider the term $N = r_1\,p_2\,(r_2\,p_1\,(r_3\,p_3\,z_\1))$ from Example~\ref{xmp:H}.
Replacing $G_j^i$ accordingly for $i \in \{0, \ldots, 5\}$ and $j \in \{1, 2, 3\}$, we have the following $\beta$-equivalences $(0)$ -- $(4)$.
$\begin{array}{lll}
(0) &\quad &S_G(N)[p_1 := \delta_\bullet, p_2 := \delta_\bullet, p_3 := \delta_\bullet] =_\beta \pi_\1 \\
(1) &\quad &S_G(N)[p_1 := \delta_\1, p_2 := \delta_\bullet, p_3 := \delta_\bullet] =_\beta \pi_\0\\
(2) &\quad &S_G(N)[p_1 := \delta_\0, p_2 := \delta_\1, p_3 := \delta_\bullet] =_\beta \pi_\0\\
(3) &\quad &S_G(N)[p_1 := \delta_\bullet, p_2 := \delta_\0, p_3 := \delta_\1] =_\beta \pi_\0\\
(4) &\quad &S_G(N)[p_1 := \delta_\bullet, p_2 := \delta_\bullet, p_3 := \delta_\0] =_\beta \pi_\0
\end{array}$

In accordance with Lemma~\ref{lem:Q_ssts_sem}, we have that $\0^4 \Rightarrow_\frakR^* \1^4 $.
Equivalences $(1)$ -- $(4)$ witness the particular rewriting steps at positions $1$ -- $4$ (cf.~Example~\ref{xmp:H} and Example~\ref{xmp:rule}).
\end{example}

Complementarily to word rewriting, the following Lemma~\ref{lem:R_ssts_sem} characterizes word expansion and initialization with $\0$s.

%  ring1 m N ->
%  stlc (Gamma_A m) N A ->
%  steps (subst (sigma_G m 0) N) (pi dollar) ->
%  steps (subst (sigma_G m 1) N) (pi one) ->
%  Forall (fun i => steps (subst (sigma_G m (S (S i))) N) (pi zero)) (seq 0 m) ->
%  exists M k, ring2 (k + m) M /\
%    stlc (Gamma_A (k + m)) M A /\
%    steps (subst (sigma_G (k + m) 0) M) (pi one) /\
%    steps (subst (sigma_G (k + m) 1) M) (pi zero) /\
%    Forall (fun i => steps (subst (sigma_G (k + m) (S (S i))) M) (pi zero)) (seq 0 (k+m)).

\begin{lemma}\label{lem:R_ssts_sem}
If $M \in \calR_1$ such that $\Gamma_1 \vdash M : \kappa$,\\
$S_G(M)[p_1 := \delta_\bullet] =_\beta \pi_\$$,
$S_G(M)[p_1 := \delta_\1] =_\beta \pi_\0$, and
$S_G(M)[p_1 := \delta_\0] =_\beta \pi_\1$,\\
then there exists an $m > 0$ and an $N \in \calQ_m$ such that $\Gamma_m \vdash N : \kappa$,\\
$S_G(N)[p_1 := G_1^0, \ldots, p_m := G_m^0] =_\beta \pi_\1$, and
$S_G(N)[p_1 := G_1^i, \ldots, p_m := G_m^i] =_\beta \pi_\0$ for $i \in \{1, \ldots, m+1\}$.
\end{lemma}

\begin{proof}[Proof\;\coq{L2017}.]
Considering the general case $M \in \calR_{m'}$ for $m' > 0$, induction on the size of $M$ and case analysis using Definition~\ref{def:ring}.
\end{proof}

The following Example~\ref{xmp:G_R} complements the previous Example~\ref{xmp:G_Q} and illustrates the intended meaning (word expansion and initialization with $\0$s) of a \enquote{well-formed} term in $\calR_1$.

\begin{example}\label{xmp:G_R}
Assume $\frakR = \{\0\0 \Rightarrow \2\2, \0\2 \Rightarrow \1\1, \2\0 \Rightarrow \1\1\}$ over the alphabet $\{\0,\1,\2\}$, and consider the terms
$M_1 := z_\star\,p_1\,(\lambda p_2.M_2)$, $M_2 := z_\star\,p_2\,(\lambda p_3.M_3)$,
$M_3 := z_\0\,p_3\,N$, and $N := r_1\,p_2\,(r_2\,p_1\,(r_3\,p_3\,z_\1))$ from Example~\ref{xmp:G_Q}.
Proceeding bottom up, we have $M_3 \in \calR_3$ and the following $\beta$-equivalences hold:\\
$\begin{array}{l}
S_G(M_3)[p_1 := \delta_\bullet, p_2 := \delta_\bullet, p_3 := \delta_\bullet] =_\beta \pi_\$\\
S_G(M_3)[p_1 := \delta_\1, p_2 := \delta_\bullet, p_3 := \delta_\bullet] =_\beta \pi_\0\\
S_G(M_3)[p_1 := \delta_\0, p_2 := \delta_\1, p_3 := \delta_\bullet] =_\beta \pi_\0\\
S_G(M_3)[p_1 := \delta_\bullet, p_2 := \delta_\0, p_3 := \delta_\1] =_\beta \pi_\0\\
S_G(M_3)[p_1 := \delta_\bullet, p_2 := \delta_\bullet, p_3 := \delta_\0] =_\beta \pi_\1
\end{array}$\\
Additionally, $M_2 \in \calR_2$, $M_1 \in \calR_1$, and the following $\beta$-equivalences hold:\\
$\begin{array}{l}
S_G(M_1)[p_1 := \delta_\bullet] =_\beta \pi_\$\\
S_G(M_1)[p_1 := \delta_\1] =_\beta \pi_\0\\
S_G(M_1)[p_1 := \delta_\0] =_\beta \pi_\1
\end{array}$
\qquad
$\begin{array}{l}
S_G(M_2)[p_1 := \delta_\bullet, p_2 := \delta_\bullet] =_\beta \pi_\$\\
S_G(M_2)[p_1 := \delta_\1, p_2 := \delta_\bullet] =_\beta \pi_\0\\
S_G(M_2)[p_1 := \delta_\0, p_2 := \delta_\1] =_\beta \pi_\0\\
S_G(M_2)[p_1 := \delta_\bullet, p_2 := \delta_\0] =_\beta \pi_\1
\end{array}$

In combination with the previous Example~\ref{xmp:G_Q}, the term $M_1 \in \calR_1$ represents word expansion up to length $4$, followed by initialization with $\0$s, and rewriting to $\1$s.
\end{example}

Next, we combine syntactic and semantic constraints in the following key Lemma~\ref{lem:ssts_to_constr}.

\begin{lemma}\label{lem:ssts_to_constr}
There exists an $n \in \bbN$ such that $\0^{n+1} \Rightarrow_\frakR^* \1^{n+1}$ iff
there exists a term $M$ in normal form, such that the following conditions hold:\\
$\emptyset \vdash M : \Gamma_1(r_1) \to \cdots \to \Gamma_1(r_L) \to \Gamma_1(z_\0) \to \Gamma_1(z_\1) \to \Gamma_1(z_\star) \to \Gamma_1(p_1) \to \kappa$,\\
$\begin{array}{ll}
M\,I \ldots I\,(\lambda h.I)\,u\,(\lambda h.\lambda g.g\,I)\,I &=_\beta u,\\
M\,H_R \ldots H_R\,H_\0\,\pi_\1\,H_\star\,\delta_\bullet &=_\beta \pi_{\$},\\
M\,G_{R_1} \ldots G_{R_L}\,G_\0\,\pi_\1\,G_\star\,\delta_\bullet &=_\beta \pi_{\$},\\
M\,G_{R_1} \ldots G_{R_L}\,G_\0\,\pi_\1\,G_\star\,\delta_\1 &=_\beta \pi_{\0},\\
M\,G_{R_1} \ldots G_{R_L}\,G_\0\,\pi_\1\,G_\star\,\delta_\0 &=_\beta \pi_{\1}.
\end{array}$
\end{lemma}

\begin{proof}[Proof\;\coq{L2758}.]
The direction from left to right proceeds in two steps.
First, by induction on the number of rewriting steps we construct a term $N \in \calQ_n$ (easy converse of Lemma~\ref{lem:Q_ssts_sem}).
Second, by induction on $n$ we construct a term $M' \in \calR_1$ containing $N \in \calQ_n$ as a subterm (easy converse of Lemma~\ref{lem:R_ssts_sem}).
Then, the solution is $M := \lambda r_1 \ldots r_L.\lambda z_\0 z_\1 z_\star p_1.M'$.

The direction from right to left is proceeds in two steps.
First, by Theorem~\ref{thm:shape} we have $\lambda r_1 \ldots r_L.\lambda z_\0 z_\1 z_\star p_1.M'$ for some $M' \in \calR_1$.
Second, by Lemma~\ref{lem:R_ssts_sem} and Lemma~\ref{lem:Q_ssts_sem} we have $\0^{n+1} \Rightarrow_\frakR^* \1^{n+1}$ for some $n > 0$.
\end{proof}

Finally, we present constraints from the above Lemma~\ref{lem:ssts_to_constr} as an instance $F_\frakR\,\mathsf{X} =_\beta N_\frakR$ of Higher-order $\beta$-Matching.
This constitutes the main result of the present work.

\begin{theorem}\label{thm:ssts_to_hom}
Problem $\0^+ \Rightarrow_\mathfrak{R}^* \1^+$ (Problem~\ref{prb:ssts01}) many-one reduces to Higher-order $\beta$-Matching (Problem~\ref{prb:hom}).
\end{theorem}

\begin{proof}[Proof\;\coq{L2880}.]
Given a simple semi-Thue system $\frakR = \{R_1, \ldots, R_L\}$ due to Lemma~\ref{lem:ssts_to_constr} there exists an $n \in \bbN$ such that $\0^{n+1} \Rightarrow_\frakR^* \1^{n+1}$ iff the instance $F_\frakR\,\mathsf{X} =_\beta N_\frakR$ of higher-order $\beta$-matching is solvable, where
\begin{itemize}
\item $F_\frakR := \lambda x.\lambda y.y \begin{array}[t]{l}
(\lambda u.x\,\underbracket{I \ldots I}_{L \text{ times}}\,(\lambda h.I)\,u\,(\lambda h.\lambda g.g\,I)\,I)\\
(x\,\underbracket{H_R \ldots H_R}_{L \text{ times}}\,H_\0\,\pi_\1\,H_\star\,\delta_\bullet)\\
(x\,G_{R_1} \ldots G_{R_L}\,G_\0\,\pi_{1}\,G_\star\,\delta_\bullet)\\
(x\,G_{R_1} \ldots G_{R_L}\,G_\0\,\pi_{1}\,G_\star\,\delta_\1)\\
(x\,G_{R_1} \ldots G_{R_L}\,G_\0\,\pi_{1}\,G_\star\,\delta_\0)
\end{array}$
\item $N_\frakR := \lambda y.y\,(\lambda u.u)\,\pi_\$\,\pi_\$\,\pi_\0\,\pi_\1$
\item $\sigma_\frakR := \Gamma_1(r_1) \to \cdots \to \Gamma_1(r_L) \to \Gamma_1(z_\0) \to \Gamma_1(z_\1) \to \Gamma_1(z_\star) \to \Gamma_1(p_1) \to \kappa$
\item $\tau_\frakR := ((\kappa \to \kappa) \to \kappa \to \kappa \to \kappa \to \kappa \to \ga) \to \ga$
\item $\emptyset \vdash F_\frakR : \sigma_\frakR \to \tau_\frakR$
\item $\emptyset \vdash N_\frakR : \tau_\frakR$\qedhere
\end{itemize}
\end{proof}

\begin{theorem}\label{thm:hom_undec}
Higher-order $\beta$-Matching (Problem~\ref{prb:hom}) is undecidable.
\end{theorem}

\begin{proof}[Proof\;\coqextra{LambdaCalculus/HOMatching\_undec.v\#L16}]
By reduction from the undecidable Problem $\0^+ \Rightarrow_\mathfrak{R}^* \1^+$ (Theorem~\ref{thm:ssts_undec} and Theorem~\ref{thm:ssts_to_hom}).
\end{proof}

We conclude the technical presentation with the following observation:
the presented approach reducing Problem $\0^+ \Rightarrow_\mathfrak{R}^* \1^+$ to Higher-order $\beta$-matching is easily transferred to intersection type inhabitation and $\lambda$-definability.

The following Remark~\ref{rem:G} shows the structure of the underlying finite model with respect to the present construction.

%\begin{remark}\label{rem:H}
%Terms in the above Definition~\ref{def:H} realize certain finite functions as follows.
%\begin{itemize}
%\item $H_\star$ realizes a member of the family $\left(\omega \mapsto ((\top \mapsto \bullet) \mapsto \$) \mapsto \$ \right)$.
%\item $H_\0$ realizes a member of the family $(\omega \mapsto (\1 \mapsto \$))$.
%\item $H_R$ realizes a member of the family $((\top \mapsto \bullet) \mapsto (\1 \mapsto \1))$.
%\end{itemize}
%\end{remark}

\begin{remark}\label{rem:G}
Terms in Definition~\ref{def:G} realize certain finite functions as follows.
\begin{itemize}
\item $G_\star$ realizes a member of the family ${\small\left(\begin{array}{l}
(\top \mapsto \bullet) \mapsto ((\top \mapsto \bullet) \mapsto \0) \mapsto \0)\\
(\top \mapsto \bullet) \mapsto \left(\left(\begin{array}{l}
(\top \mapsto \bullet) \mapsto \$\\
(\top \mapsto \0) \mapsto \1
\end{array}\right) \mapsto \$\right)\\
(\top \mapsto \0) \mapsto ((\top \mapsto \1) \mapsto \0) \mapsto \1)\\
(\top \mapsto \1) \mapsto ((\top \mapsto \bullet) \mapsto \0) \mapsto \0)
\end{array}\right)}$.
\item $G_\0$ realizes a member of the family ${\small\left(\begin{array}{l}
(\top \mapsto \bullet) \mapsto (\0 \mapsto \0)\\
(\top \mapsto \bullet) \mapsto (\1 \mapsto \$)\\
(\top \mapsto \0) \mapsto (\0 \mapsto \1)\\
(\top \mapsto \1) \mapsto (\0 \mapsto \0)
\end{array}\right)}$.
\item $G_{ab \Rightarrow cd}$ realizes a member of the family ${\small\left(\begin{array}{l}
(\top \mapsto \1) \mapsto (c \mapsto a)\\
(\top \mapsto \0) \mapsto (d \mapsto b)
\end{array}\right)}$ such that\\
$G_{ab \Rightarrow cd} \, \delta_\bullet \, \pi_i =_\beta \pi_i$ for $i \in \calA$.
\end{itemize}
\end{remark}

The above families finite function specifications are immediately represented by intersection types.
Let us state in the following Proposition~\ref{prop:uniform} the relationship between simple semi-Thue system rewriting, Higher-order $\beta$-matching, $\lambda$-definability, and intersection type inhabitation.

\begin{proposition}\label{prop:uniform}
Given a simple semi-Thue system $\frakR$, one can construct simply typed terms $\emptyset \vdash F_\frakR : \sigma_\frakR \to \tau_\frakR$ and $\emptyset \vdash N_\frakR : \tau_\frakR$, an intersection type $T_\frakR$, and a finite function $\calF_\frakR$ such that the following statements are equivalent:
\begin{enumerate}
\item There exists an $n \in \bbN$ such that $\0^{n+1} \Rightarrow_\frakR^* \1^{n+1}$.
\item The instance $F_\frakR\,\mathsf{X} =_\beta N_\frakR$ of Higher-order $\beta$-Matching is solvable.
\item The intersection type $T_\frakR$ is inhabited.
\item The finite function $\calF_\frakR$ is $\lambda$-definable.
\end{enumerate}
\end{proposition}

Of course, $(1) \Rightarrow (3)$ can be concluded from undecidability of intersection type inhabitation~\cite{Urzyczyn09} and $(1) \Rightarrow (4)$ from undecidability of $\lambda$-definability~\cite{loader2001undecidability}.
The presented approach shows $(1) \Rightarrow (2)$, and we make the following two observations.
First, referring to Remark~\ref{rem:R1}, the approach is inspired by and easily adapted to show $(1) \Rightarrow (3)$, such that the inhabitant is essentially a member of $\calR_1$.
Second, based on Remark~\ref{rem:G}, the approach can be adapted to show $(1) \Rightarrow (4)$, such that the realizer is essentially a member of $\calR_1$.
This is supported by the known equivalence between (a fragment of) intersection type inhabitation and $\lambda$-definability~\cite{SalvatiMGB12}.

\newpage

\section{Mechanization}\label{sec:mech}

This section provides a brief overview over the mechanization of undecidability of Higher-order $\beta$-Matching (Theorem~\ref{thm:hom_undec}) using the Coq proof assistant~\cite{Coq_2023}.
The mechanization is axiom-free and spans approximately $4000$ lines of code, consisting of the following parts:
\begin{itemize}
\item \texttt{HOMatching.v} contains definitions of the simply typed $\lambda$-calculus~\coqextra{LambdaCalculus/HOMatching.v\#L31} and Higher-order $\beta$-matching~\coqextra{LambdaCalculus/HOMatching.v\#L37}.
\item \texttt{Util/stlc\_facts.v} and \texttt{Util/term\_facts.v} contain basic properties of the simply typed $\lambda$-calculus, such as confluence of $\beta$-reduction~\coqextra{LambdaCalculus/Util/term\_facts.v\#L1056}, substitution lemmas~\coqextra{LambdaCalculus/Util/stlc\_facts.v\#L100}, and type preservation properties~\coqextra{LambdaCalculus/Util/stlc\_facts.v\#L116}.
\item \texttt{Reductions/SSTS01\_to\_HOMbeta.v} contains the reduction from Problem $\0^+ \Rightarrow_\mathfrak{R}^* \1^+$ to Higher-order $\beta$-Matching~\coq{L2880}.
\item \texttt{HOMatching\_undec.v} contains the undecidability result for Higher-order $\beta$-Matching~\coqextra{LambdaCalculus/HOMatching\_undec.v\#L16}.
\end{itemize}

The simple type system \texttt{stlc} is mechanized in \texttt{HOMatching.v}, borrowing the existing term definitions from the library~\coqextra{L/L.v\#L8}, for which variable binding is addressed via the unscoped de Bruijn approach~\cite{deBruijn72}.
The proposition \texttt{stlc~Gamma~M~t} mechanizes that the term \texttt{M} is assigned the simple type~\texttt{t} in the simple type environment \texttt{Gamma}.
\begin{lstlisting}[mathescape]
Inductive ty : Type :=
  | atom (* type variable *)
  | arr (s t : ty). (* function type *)

Inductive term : Type :=
  | var (n : nat) : term (* term variable *)
  | app (s : term) (t : term) : term (* application *)
  | lam (s : term). (* abstraction *)

Inductive stlc (Gamma : list ty) : term -> ty -> Prop :=
  | stlc_var x t : nth_error Gamma x = Some t ->
      stlc Gamma (var x) t (* variable rule *)
  | stlc_app M N s t : stlc Gamma M (arr s t) -> stlc Gamma N s ->
      stlc Gamma (app M N) t (* application rule *)
  | stlc_lam M s t : stlc (cons s Gamma) M t ->
      stlc Gamma (lam M) (arr s t). (* abstraction rule *)
\end{lstlisting}

Higher-order $\beta$-Matching is mechanized as the predicate \texttt{HOMbeta}: given terms \texttt{F} of type \texttt{arr s t} and \texttt{N} of type \texttt{t}, is there a simply typed term \texttt{M} of type \texttt{s} such that \texttt{app F M} is $\beta$-equivalent (reflexive, symmetric, transitive closure of \texttt{step}) to \texttt{N}?
\begin{lstlisting}[mathescape]
Definition HOMbeta : { '(s, t, F, N) : (ty * ty * term * term) 
  | stlc nil F (arr s t) /\ stlc nil N t } -> Prop :=
    fun '(exist _ (s, t, F, N) _) =>
      exists (M : term), stlc nil M s /\
        clos_refl_sym_trans term step (app F M) N.
\end{lstlisting}

The proposition \lstinline|undecidable HOMbeta|~\coqextra{LambdaCalculus/HOMatching\_undec.v\#L16} mechanizes the undecidability of the predicate \texttt{HOMbeta}, relying on the following library definition~\cite{CLUP20}.
A predicate \texttt{p} is undecidable, if existence of a computable decider for \texttt{p} implies recursive co-enumerability of the (Turing machine) Halting Problem.
\begin{lstlisting}[mathescape]
Definition undecidable {X} (p : X -> Prop) :=
  decidable p -> enumerable (complement SBTM_HALT).
\end{lstlisting}
Since the Halting Problem is recursively enumerable, decidability of \texttt{p} would imply decidability of the Halting Problem.

\section{Conclusion}\label{sec:concl}
The present work presents a new, mechanized proof of the undecidability of Higher-order $\beta$-matching.
%Building upon existing work, we obtain a certified many-one reduction from the Turing machine Halting Problem to Higher-order $\beta$-matching.
The mechanization is contributed to the existing Coq Library of Undecidability Proofs~\cite{CLUP20}.

While the previous proof by Loader~\cite{Loader03} is based on (a variant of) $\lambda$-definability, the presented proof reduces a rewriting problem (Problem $\0^+ \Rightarrow_\mathfrak{R}^* \1^+$) to Higher-order $\beta$-matching.
As a result, the proof is simpler to verify in full detail and yields a concise mechanization.
Additionally, undecidability of the particular rewriting problem is already mechanized, and is part the Coq Library of Undecidability Proofs.

Besides the main technical result, we argue that the present approach is uniformly applicable to show undecidability of intersection type inhabitation and $\lambda$-definability.
The former is already established as refinement~\cite{DudenhefnerR19} of Urzyczyn's undecidability result~\cite{Urzyczyn09}.
The latter is an application of the known correspondence between intersection type inhabitation and $\lambda$-definability~\cite{SalvatiMGB12}.

The \emph{order} of a type is the maximal nesting depth of the arrow type constructor to the left, starting by $\text{order}(\ga) = 1$.
The present approach agrees with Loader's result that $\beta$-Matching is undecidable at order $6$.
While Loader conjectures that order $5$ may suffice, the present work suggests that this might not be the case.
Constraining the shape of candidate solutions both in the present work as well as in Loader's proof seems to necessitate order $6$.
Still, decidability of $\beta$-Matching at order $5$ remains an open question.

Interaction with a proof assistant supported the formation process of the present approach.
While proofs of the individual lemmas are quite simplistic, they involve exhaustive case analyses and are sensitive to the exact details of the underlying construction.
Bookkeeping capabilities of the Coq proof assistant and quick adaptability to an evolving construction were of great benefit.
Additionally, once all cases are covered, there is no room for doubt that the construction is correct.
As a result, the proof was developed via interaction with the proof assistant prior to being transcribed into a traditional written format.

\newpage

\bibliography{bibliography}

\end{document}
