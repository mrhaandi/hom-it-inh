\documentclass[a4paper,USenglish,cleveref, autoref, thm-restate]{lipics-v2021}
%This is a template for producing LIPIcs articles. 
%See lipics-v2021-authors-guidelines.pdf for further information.
%for A4 paper format use option "a4paper", for US-letter use option "letterpaper"
%for british hyphenation rules use option "UKenglish", for american hyphenation rules use option "USenglish"
%for section-numbered lemmas etc., use "numberwithinsect"
%for enabling cleveref support, use "cleveref"
%for enabling autoref support, use "autoref"
%for anonymousing the authors (e.g. for double-blind review), add "anonymous"
%for enabling thm-restate support, use "thm-restate"
%for enabling a two-column layout for the author/affilation part (only applicable for > 6 authors), use "authorcolumns"
%for producing a PDF according the PDF/A standard, add "pdfa"

%\pdfoutput=1 %uncomment to ensure pdflatex processing (mandatatory e.g. to submit to arXiv)
%\hideLIPIcs  %uncomment to remove references to LIPIcs series (logo, DOI, ...), e.g. when preparing a pre-final version to be uploaded to arXiv or another public repository

%\graphicspath{{./graphics/}}%helpful if your graphic files are in another directory

\bibliographystyle{plainurl}% the mandatory bibstyle

\title{Mechanized Undecidability of Higher-order beta-Matching} %TODO Please add

%\titlerunning{Dummy short title} %TODO optional, please use if title is longer than one line

\author{Andrej Dudenhefner}{TU Dortmund University, Germany}{andrej.dudenhefner@cs.tu-dortmund.de}{https://orcid.org/0000-0003-1104-444X}{}
%TODO mandatory, please use full name; only 1 author per \author macro; first two parameters are mandatory, other parameters can be empty. Please provide at least the name of the affiliation and the country. The full address is optional. Use additional curly braces to indicate the correct name splitting when the last name consists of multiple name parts.

\authorrunning{A. Dudenhefner} %TODO mandatory. First: Use abbreviated first/middle names. Second (only in severe cases): Use first author plus 'et al.'

\Copyright{Andrej Dudenhefner} %TODO mandatory, please use full first names. LIPIcs license is "CC-BY";  http://creativecommons.org/licenses/by/3.0/

\ccsdesc[500]{Theory of computation~Lambda calculus} %TODO mandatory: Please choose ACM 2012 classifications from https://dl.acm.org/ccs/ccs_flat.cfm 

\keywords{lambda-calculus, simple types, undecidability, higher-order matching, mechanization, Coq} %TODO mandatory; please add comma-separated list of keywords

\category{} %optional, e.g. invited paper

\relatedversion{} %optional, e.g. full version hosted on arXiv, HAL, or other respository/website
%\relatedversiondetails[linktext={opt. text shown instead of the URL}, cite=DBLP:books/mk/GrayR93]{Classification (e.g. Full Version, Extended Version, Previous Version}{URL to related version} %linktext and cite are optional

\supplementdetails[subcategory={Source Code},linktext={coq-library-undecidability}]{Software}{https://github.com/uds-psl/coq-library-undecidability/} %linktext, cite, and subcategory are optional
%\supplement{}%optional, e.g. related research data, source code, ... hosted on a repository like zenodo, figshare, GitHub, ...
%\supplementdetails[linktext={opt. text shown instead of the URL}, cite=DBLP:books/mk/GrayR93, subcategory={Description, Subcategory}, swhid={Software Heritage Identifier}]{General Classification (e.g. Software, Dataset, Model, ...)}{URL to related version} %linktext, cite, and subcategory are optional

%\funding{(Optional) general funding statement \dots}%optional, to capture a funding statement, which applies to all authors. Please enter author specific funding statements as fifth argument of the \author macro.

%\acknowledgements{I want to thank \dots}%optional

%\nolinenumbers %uncomment to disable line numbering

%Editor-only macros:: begin (do not touch as author)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\EventEditors{John Q. Open and Joan R. Access}
\EventNoEds{2}
\EventLongTitle{42nd Conference on Very Important Topics (CVIT 2016)}
\EventShortTitle{CVIT 2016}
\EventAcronym{CVIT}
\EventYear{2016}
\EventDate{December 24--27, 2016}
\EventLocation{Little Whinging, United Kingdom}
\EventLogo{}
\SeriesVolume{42}
\ArticleNo{23}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage[a-1b]{pdfx}
\usepackage{wasysym} %\brokenvert
\usepackage{csquotes} %\enquote{} macro
\usepackage{bussproofs}
\usepackage{mathtools}
\usepackage[dvipsnames]{xcolor}

\theoremstyle{definition}
\newtheorem{problem}[theorem]{Problem}

%%%%%%%%%%%%%%%%%% specific %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\DeclareMathOperator{\id}{id}
\DeclareMathOperator{\length}{length}
\DeclareMathOperator{\depth}{depth}

%%%%%%%%%%%%%%%%%%%%%%%% stylized symbols %%%%<%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\bbB}{\mathbb{B}}
\newcommand{\bbC}{\mathbb{C}}
\newcommand{\bbN}{\mathbb{N}}
\newcommand{\bbT}{\mathbb{T}}
\newcommand{\bbS}{\mathbb{S}}
\newcommand{\bbV}{\mathbb{V}}
\newcommand{\bbZ}{\mathbb{Z}}
\newcommand{\calA}{\mathcal{A}}
\newcommand{\calC}{\mathcal{C}}
\newcommand{\calD}{\mathcal{D}}
\newcommand{\calF}{\mathcal{F}}
\newcommand{\calM}{\mathcal{M}}
\newcommand{\calQ}{\mathcal{Q}}
\newcommand{\calR}{\mathcal{R}}
\newcommand{\calT}{\mathcal{T}}
\newcommand{\calU}{\mathcal{U}}

\newcommand{\frakR}{\mathfrak{R}}

\newcommand{\0}{\mathbf{0}}
\newcommand{\1}{\mathbf{1}}
\newcommand{\2}{\mathbf{2}}
\newcommand{\K}{\mathbf{K}}

\newcommand{\case}[2]{\ensuremath{\textnormal{\textbf{case }} #1 \textnormal{\textbf{ of }} \langle #2 \rangle}}
\newcommand{\caseelse}[3]{\ensuremath{\textnormal{\textbf{case }} {#1} \textnormal{\textbf{ of }} \langle #3 \mid #2 \rangle}}
\newcommand{\ite}[4]{\ensuremath{\textbf{if } #1 \textbf{ is } #2 \textbf{ then } #3 \textbf{ else } #4}}
\newcommand{\itb}[3]{\ensuremath{\textbf{if } #1 \textbf{ is } #2 \textbf{ then } #3}}

\newcommand{\coq}[1]{\textnormal{[\href{https://github.com/uds-psl/coq-library-undecidability/blob/70dfc56f33a6e4835281044e68aa68279989047e/theories/LambdaCalculus/Reductions/SSTS01\_to\_HOMbeta.v\##1}{\raisebox{-0.2em}{\includegraphics[width=0.6em]{coq-logo.pdf}}}]}}
\newcommand{\coqextra}[1]{\textnormal{[\href{https://github.com/uds-psl/coq-library-undecidability/blob/70dfc56f33a6e4835281044e68aa68279989047e/theories/#1}{\raisebox{-0.2em}{\includegraphics[width=0.6em]{coq-logo.pdf}}}]}}

\newcommand{\isep}{-0.4em}

%%%%%%%%%%%%%%%%%%%%%%%%% Abbreviations etc. %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\ga}{\ensuremath{\iota}}

\begin{document}

\maketitle

%TODO mandatory: add short abstract of the document
\begin{abstract}
Higher-order beta-matching is the following decision problem: given two simply typed lambda-terms, can the first term be instantiated to be beta-equivalent to the second term?
This problem was formulated by Huet in the 1970s and shown undecidable by Loader in 2003.
The particular proof is by reduction from an ad-hoc definability problem for finite models of the simply-typed lambda-calculus.

The present work presents a novel undecidability proof of higher-order beta-matching, in an effort to verify this result by means of a proof assistant in full detail.
Rather than starting from lambda-definability, the presented proof encodes a restricted form of string rewriting as higher-order beta-matching.
The particular approach is similar to Urzyczyn's undecidability result for intersection type inhabitation.

The presented approach has several benefits.
First, the proof is simpler to verify in full detail due to the simple form of rewriting systems, which serve as a starting point.
Second, undecidability of the considered problem in string rewriting is already certified using the Coq proof assistant.
Building upon the existing work, we obtain a certified many-one reduction from the Turing-machine halting problem to higher-order beta-matching.
Third, the presented approach identifies a uniform construction which shows undecidability of higher-order beta-matching, lambda-definability, and intersection type inhabitation.

The presented undecidability proof is mechanized in the Coq proof assistant and contributed to the existing Coq library of undecidability proofs.
\end{abstract}

\lstset{
basicstyle=\ttfamily\footnotesize,
keywordstyle=\color{blue},
morekeywords={Inductive,Type,Theorem},}

\section{Preliminaries}

\subsection*{Simply-typed $\lambda$-Calculus}

\begin{definition}[$\lambda$-Terms]
\[
\begin{array}{rcl}
M, N &::= &x \mid M \, N \mid \lambda x.M
\end{array}
\]
\end{definition}

\begin{definition}[$\beta$-Reduction]~
\begin{itemize}
\item $\to_\beta$ is the contextual closure of $(\lambda x.M)\,N \to_\beta M[x := N]$
\item $\twoheadrightarrow_\beta$ is the reflexive, transitive closure of $\to_\beta$
\item $=_\beta$ is the reflexive, transitive, symmetric closure of $\to_\beta$
\end{itemize}
\end{definition}

\begin{definition}[Simple Types with Ground Atom $\ga$]
\[
\begin{array}{rcl}
\sigma, \tau &::= &\ga \mid \sigma \to \tau
\end{array}
\]
\end{definition}

\begin{definition}[Type Environments]
\[
\begin{array}{rcl}
\Gamma &::= &\{x_1 : \sigma_1, \ldots, x_n : \sigma_n\}
\end{array}
\]
\end{definition}

\begin{definition}[Simple Type System]~\\
\begin{tabular}{ccc}
{%\RightLabel{\textnormal{(Var)}}
\AxiomC{$(x : \sigma) \in \Gamma$}
\UnaryInfC{$\Gamma \vdash x : \sigma$}
\DisplayProof}
&
{%\RightLabel{\textnormal{($\to$I)}}
\AxiomC{$\Gamma, x : \sigma \vdash M : \tau$}
\UnaryInfC{$\Gamma \vdash \lambda x.M : \sigma \to \tau$}
\DisplayProof}
&
{%\RightLabel{\textnormal{($\to$E)}}
\AxiomC{$\Gamma \vdash M : \sigma \to \tau$}
\AxiomC{$\Gamma \vdash N : \sigma$}
\BinaryInfC{$\Gamma \vdash M\,N : \tau$}
\DisplayProof}
\end{tabular}
\end{definition}

\subsection*{Higher-order $\beta$-Matching}

\begin{problem}[Higher-order $\beta$-Matching (${F}\,\mathsf{X} = N$)]\label{prb:hom}
Given terms $F, N$ and simple types $\sigma, \tau$ such that $\emptyset \vdash F : \sigma \to \tau$ and $\emptyset \vdash N : \tau$, is there a term $M$ such that $\emptyset \vdash M : \sigma$ and $F\,M =_\beta N$?
\end{problem}

\begin{theorem}[{\cite[Theorem~5.5]{Loader03}}]
Higher-order $\beta$-matching is undecidable.
\end{theorem}

\begin{proof}[Proof Outline]
Many-one reduction from an ad-hoc variant of $\lambda$-definability.
\end{proof}

\begin{remark}
Artifacts
\begin{itemize}
\item \emph{myopic} $\lambda\bot$-terms and \emph{myopic} order
\item characterization of $1$-lifts and $7$-lifts by \emph{checker} $\lambda\bot$-terms
\item characterization of finite models by $(7+1)$-lifted terms\qedhere
\end{itemize}
\end{remark}

\begin{definition}[Matching Constraint]
$\mathsf{X}\,F_1 \ldots F_n = N$\\
TODO: is this needed?
\end{definition}

\begin{lemma}
Given matching constraints $\mathsf{X}\,F_1^1 \ldots F_n^1 = N^1, \ldots, \mathsf{X}\,F_1^m \ldots F_n^m = N^m$, the matching problem instance $F\,\mathsf{X} = N$ is solvable iff 
\end{lemma}

\subsection*{Finite Models}

\begin{definition}[Finite Model]
Fix a finite set $\calM_\ga$, $\calM_{\sigma \to \tau}$ is the finite set of all functions from $\calM_\sigma$ to $\calM_\tau$.
\end{definition}

We use tabular notation for families of finite functions in a given finite model, illustrated by the following examples.

\setlength{\arraycolsep}{1pt}

\begin{example}
Fix the finite model $\calM$ with $\calM_\ga = \{1, 2\}$.
The family ${\small\left(\begin{array}{c}
1 \mapsto 2\\
2 \mapsto 1
\end{array}\right)} \subseteq \calM_{\ga \to \ga}$ contains exactly one finite function $f \in \calM_{\ga \to \ga}$ where $f(1) = 2$, $f(2) = 1$.
\end{example}

\begin{example}
Fix the finite model $\calM$ with $\calM_\ga = \{1, 2, 3\}$.
The family ${\small\left(\begin{array}{c}
1 \mapsto 2\\
2 \mapsto 3
\end{array}\right)} \subseteq \calM_{\ga \to \ga}$ contains exactly three distinct finite functions $f \in \calM_{\ga \to \ga}$ where $f(1) = 2$, $f(2) = 3$, and $f(3) \in \{1, 2, 3\}$.
\end{example}

\begin{example}\label{xmp:fin-model}
Fix the finite model $\calM$ with $\calM_\ga = \{1, 2, 3\}$. The family $\left({\small\left(\begin{array}{c}
1 \mapsto 2\\
2 \mapsto 3
\end{array}\right)} \mapsto (1 \mapsto 3)\right)$ contains finite functions $f \in \calM_{(\ga \to \ga) \to \ga \to \ga}$ such that $f(g)(1) = 3$ for any $g \in {\small\left(\begin{array}{c}
1 \mapsto 2\\
2 \mapsto 3
\end{array}\right)}$.

As a side note, there is a $\lambda$-definable member of $\left({\small\left(\begin{array}{c}
1 \mapsto 2\\
2 \mapsto 3
\end{array}\right)} \mapsto (1 \mapsto 3)\right)$ realized by the $\lambda$-term $\lambda f.\lambda x.f\,(f\,x)$.
\end{example}

\subsection*{Simple Semi-Thue Systems}

\begin{definition}[Simple Semi-Thue System]
A semi-Thue system $\calR$ over an alphabet $\calA$ is \emph{simple}, if each rule has the form $ab \Rightarrow cd$ for $a,b,c,d \in \calA$.
\end{definition}

\begin{remark}
Simple Semi-Thue System inspired by \enquote{\emph{Inhabitation of Low-Rank Intersection Types}}~[\cite{Urzyczyn09}]
and \enquote{\emph{Loader and Urzyczyn Are Logically Related}}~[\cite{SalvatiMGB12}].
\end{remark}


\begin{example}\label{xmp:ssts}
Let $\frakR  := \{\0\0 \Rightarrow \2\2, \0\2 \Rightarrow \1\1, \2\0 \Rightarrow \1\1\}$ be a simple semi-Thue system over the alphabet $\{\0,\1,\2\}$.
We have $\0\0\0\0 \Rightarrow_\frakR \0\2\2\0 \Rightarrow_\frakR \1\1\2\0 \Rightarrow_\frakR \1\1\1\1$. Additionally, we have $\0^n \;{\not\Rightarrow}_\frakR^*\; \1^n$ for $n \in \{1, 2, 3\}$.
\end{example}

\begin{problem}[$\0^+ \Rightarrow^*_\calR \1^+$]\label{prb:ssts01}
Given a simple semi-Thue system $\frakR$, does $\0^n \Rightarrow^*_\frakR \1^n$ hold for some $n > 0$?
\end{problem}

\begin{remark}
Problem~\ref{prb:ssts01} used as a starting point in~\cite{DudenhefnerR19} by Dudenhefner.
\end{remark}

\begin{theorem}[{\cite[Lemma~3.3]{DudenhefnerR19}}]\label{thm:ssts_undec}
Problem $\0^+ \Rightarrow^*_\calR \1^+$ is undecidable.
\end{theorem}

\begin{remark}~
\begin{itemize}
\item similar to \cite[Lemma~2]{Urzyczyn09}
\item mechanized in Coq~\cite[\texttt{SSTS01}]{CLUP20}
\end{itemize}
\end{remark}

\newpage

\section{Shape Constraint and Loader}
Before we present an alternative approach to undecidability of higher-order $\beta$-matching, let us first get familiar with tools at our disposal.



Two examples.
First, in which there is only a semantic constraint and where the solution is wrong and arbitrary syntax.

\begin{example}\label{xmp:ad-hoc}
Consider the finite model $\calM$ from Example~\ref{xmp:fin-model} with $\calM_\ga = \{1, 2, 3\}$ together with the family $\calF = \left({\small\left(\begin{array}{c}
1 \mapsto 2\\
2 \mapsto 3
\end{array}\right)} \mapsto (1 \mapsto 3)\right)$ of finite functions.

Let us realize elements of the set $\{1, 2, 3\}$ by projections $\pi_1 := \lambda xyz.x$, $\pi_2 := \lambda xyz.y$, and $\pi_3 := \lambda xyz.z$ respectively.
For the term $G := \lambda h.\lambda x y z.h\,y\,z\,x$ we have
\[G\,\pi_1 \twoheadrightarrow_\beta \pi_2 \text{ and } G\,\pi_2 \twoheadrightarrow_\beta \pi_3\]
Therefore, $G$ realizes a member of ${\small\left(\begin{array}{c}
1 \mapsto 2\\
2 \mapsto 3
\end{array}\right)}$.
Consider the matching constraint $\mathsf{X}\,G\,\pi_1 =_\beta \pi_3$.
Any term which realizes a member of the family $\calF$ solves the above constraint.
For instance, we have $\big(\lambda f.\lambda t.f\,(f\,t)\big)\,G\,\pi_1 \twoheadrightarrow_\beta \pi_3$.

However, the converse is not true.
One obvious solution to the above constraint is the term $\lambda f.\lambda t.\pi_3$ because $\big(\lambda f.\lambda t.\pi_3\big)\,G\,\pi_1
\twoheadrightarrow_\beta \pi_3$.
Another solution to the above constraint is the term $\lambda f.\lambda t.\lambda x y z.t\,z\,z\,z$ because $\big(\lambda f.\lambda t.\lambda x y z.t\,z\,z\,z\big)\,G\,\pi_1
\twoheadrightarrow_\beta \lambda x y z.\pi_1\,z\,z\,z \twoheadrightarrow_\beta \pi_3$.
Both solutions construct realizers of the set $\{1, 2, 3\}$ via explicit abstraction $\lambda x y z.[\ldots]$.
\end{example}

In the simply typed setting an additional constraint suffices in order to exclude above ad-hoc solutions, illustrated in the following Example~\ref{xmp:no-ad-hoc}.

\begin{example}\label{xmp:no-ad-hoc}
Consider a solution $M$ in normal form for matching constraint $\mathsf{X}\,(\lambda x.x)\,u =_\beta u$ where $u$ is a term variable.
Additionally, assume that $\emptyset \vdash M : (\sigma \to \sigma) \to \sigma \to \sigma$ for some simple type $\sigma$.
By case analysis on $M$ we have that $M = \lambda f.\lambda t.N$ for some term $N$ in normal form which is not an abstraction.
Furthermore, $\{f : \sigma \to \sigma, t : \sigma\} \vdash N : \sigma$ and $N[f := \lambda x.x, t := u] \twoheadrightarrow_\beta u$.
By induction on the size of $N$ and case analysis we have that $N = t$ or $N = f\,(\ldots(f\,t)\ldots)$.

As a result, any solution to both matching constraints $\mathsf{X}\,(\lambda h.\lambda x y z.h\,y\,z\,x)\,\pi_1 =_\beta \pi_3$ and $\mathsf{X}\,(\lambda x.x)\,u =_\beta u$ realizes a member of the family $\left({\small\left(\begin{array}{c}
1 \mapsto 2\\
2 \mapsto 3
\end{array}\right)} \mapsto (1 \mapsto 3)\right)$.

Ad-hoc solutions such as $\lambda f.\lambda t.\pi_3$ or $\lambda f.\lambda t.\lambda x y z.t\,z\,z\,z$ from Example~\ref{xmp:ad-hoc} do not solve the constraint $\mathsf{X}\,(\lambda x.x)\,u =_\beta u$ because such solutions contain too many abstractions on the right-hand side.
\end{example}

\begin{remark}\label{rem:eta-break}
Example~\ref{xmp:no-ad-hoc} demonstrates that certain matching constraints restrict the number of abstractions in solutions.
However, in the presence of $\eta$-reduction this does not work, as shown below.
Considering $G := \lambda h.\lambda x y z.h\,y\,z\,x$, $\pi_1 = \lambda xyz.x$, $\pi_2 = \lambda xyz.y$, and $\pi_3 = \lambda xyz.z$ from Example~\ref{xmp:no-ad-hoc}, the term $M := \lambda g.\lambda h.\lambda xyz.h\,(g\,\pi_1 x\,z\,y)\,y\,z$ solves both constraints $\mathsf{X}\,G\,\pi_1 =_{\beta\eta} \pi_3$ and $\mathsf{X}\,(\lambda x.x)\,u =_{\beta\eta} u$ as follows:\\
$\arraycolsep=1.4pt\begin{array}[t]{lclcl}
M\,G\,\pi_1 &=& \big(\lambda g.\lambda h.\lambda xyz.h\,(g\,\pi_1 x\,z\,y)\,y\,z\big)\,G\,\pi_1
&\twoheadrightarrow_\beta& \lambda xyz.\pi_{1}\,(G\,\pi_1 x\,z\,y)\,y\,z\\
&\twoheadrightarrow_\beta& \lambda xyz.G\,\pi_1 x\,z\,y
&\twoheadrightarrow_\beta& \lambda xyz.\pi_1\,z\,y\,x \twoheadrightarrow_\beta \lambda xyz.z = \pi_{3}
\end{array}$\\
$\arraycolsep=1.4pt\begin{array}[t]{lclcl}
M\,(\lambda x.x)\,u &=& \big(\lambda g.\lambda h.\lambda xyz.h\,(g\,\pi_1 x\,z\,y)\,y\,z\big)\,(\lambda x.x)\,u
&\twoheadrightarrow_\beta& \lambda xyz.u\,((\lambda x.x)\,\pi_1 x\,z\,y)\,y\,z\\
&\twoheadrightarrow_\beta& \lambda xyz.u\,(\pi_1 x\,z\,y)\,y\,z &\twoheadrightarrow_\beta& \lambda xyz.u\,x\,y\,z \twoheadrightarrow_\eta u
\end{array}$\\
In addition, we have $\emptyset \vdash M : (\sigma \to \sigma) \to \sigma \to \sigma$ for $\sigma := \ga \to \ga \to \ga \to \ga$.
\end{remark}


The observation from the above Example~\ref{xmp:no-ad-hoc} is generalized by Loader to arbitrary families of finite functions.
This results in undecidability, of higher-order $\beta$-matching by reduction from (a variant of) $\lambda$-definability.

Loader's generalization is quite sophisticated, as it requires construction principles to restrict shapes of realizers of arbitrary finite functions of arbitrary order.
In the present work, we focus on a fragment, which can be identified identified by Urzyczyn and Salvati et.al.
This leads to a simpler proof and a connection between undecidability of HOmachting, intersection type inhabitation, and lambda-definability.

\newpage

\setlength{\abovedisplayskip}{3pt}
\setlength{\belowdisplayskip}{3pt}

\section{Undecidability of Higher-order $\beta$-Matching}
In this section we develop our main result (Theorem~\ref{thm:ssts_to_hom}): a reduction from the rewriting problem $\0^+ \Rightarrow_\mathfrak{R}^* \1^+$ to Higher-order $\beta$-Matching.

For the remainder of the section we fix the simple semi-Thue system $\frakR := \{R_1, \ldots, R_L\}$ with $L > 0$ rules over the finite alphabet $\{\0, \1, \2, \ldots, \mathbf{K}\}$.
Our approach is to construct simply typed terms which capture the two main aspects of the rewriting problem $\0^+ \Rightarrow_\mathfrak{R}^* \1^+$: the search for a sufficiently long starting sequence of $\0$s, and the individual rewriting steps to the resulting sequence of $\1$s.

The remainder of the present section is structured as follows.
First, we fix basic notation, encoding, and properties of the rewriting in the system $\frakR$.
Second, we constraint the shape of potential solutions for the constructed matching instance, similarly to Example~\ref{xmp:no-ad-hoc}.
Third, for solutions of restricted shape we capture the functional properties of the rewriting problem $\0^+ \Rightarrow_\mathfrak{R}^* \1^+$.

\subsection*{Notation}

We introduce four additional symbols in extended alphabet $\calA := \{\0, \1, \ldots, \mathbf{K}\} \cup \{\$, \bullet, \top, \bot\}$.
We represent an alphabet symbol $i \in \calA$ as the projection $\pi_i := \lambda s_\0 s_\1 \ldots s_\K s_\$ s_\bullet s_\top s_\bot.s_i$ typed by the simple type $\kappa := \underbracket{\ga \to \ldots \to \ga}_{|\calA|~\text{times}} \to \ga$.
For readability, we use the following $\textbf{case}$ notation to match individual symbols.

\begin{definition}[\textbf{case}]\label{def:case}
For $k \in \bbN$, distinct $i_1, \ldots, i_k \in \calA$, and terms $M_1, \ldots, M_k$:
\begin{align*}
\caseelse{x}{i_1 \mapsto M_1 \mid \ldots \mid i_k \mapsto M_k}{M} := &~x\,N_\0\,N_\1 \ldots N_\K\,N_\$\,N_\bullet\,N_\top\,N_\bot\\
&\text{ where } N_i = \begin{cases} M_j & \text{if } i = i_j\\M & \text{otherwise}\end{cases}
\end{align*}
\end{definition}
A particular term $\delta_i$ for $i \in \calA$, which we will use commonly is:
\[\delta_i := \lambda x.\lambda s_\0 s_\1 \ldots s_\K s_\$ s_\bullet s_\top s_\bot.\caseelse{x}{\top \mapsto s_i}{s_\bot}\]
We have $\emptyset \vdash \delta_i : \kappa \to \kappa$, and the following Lemma~\ref{lem:delta} specifies the behavior of $\delta_i$.

\begin{lemma}\label{lem:delta}
For $i, j \in \calA$ such that $i \neq j$ we have
$\delta_i\,\pi_\top =_\beta \pi_i$ and $\delta_i\,\pi_j =_\beta \pi_\bot$.
\end{lemma}

As is usual, we define $I := \lambda x.x$, and for the remainder of the present section we assign the simple type $\kappa \to \kappa$ to each occurrence of $I$.

\subsection*{Syntactic Constrains}
We identify the shape of \enquote{well-formed} terms, suitable to represent rewriting.
In the following Definition~\ref{def:ring} terms in the set $\calQ_m$ capture consecutive rule application for a word of length $m + 1$, ending in the word $\1^{m+1}$ (represented by $z_\1 \in \calQ_m$).
The subterm $r_i\,p_j$ (and $r_i\,(\lambda w.p_j\,w)$) for $i \in \{1, \ldots, L\}$ and $j \in \{1, \ldots, m\}$ indicates an application of the rule $R_i$ at position $j$.
Additionally, terms in the set $\calR_m$ capture consecutive increase of word length starting with $m+1$, and initialization with $\0$s before rewriting (represented by $z_\0\,N\,M \in \calR_m$ for $M \in \calQ_m$).
Specifically, the subterm $(z_\star\,N\,(\lambda p_{m+1}.M))$ introduces an additional bound variable $p_{m+1}$ in order the argue about rule application at position $m+1$ in the longer word.
As a special case, terms in $\calR_1$ represent candidates witnessing an arbitrary expansion of a word of length $2$, followed by initialization with $\0$s, and consecutively rewritten to $\1$s.

\begin{definition}[Sets $\calQ_m$, $\calR_m$ of Terms]\label{def:ring}
For $m > 0$ let $\calQ_m$ and $\calR_m$ be the smallest sets of terms satisfying the following rules:
\begin{itemize}
\item $z_\1 \in \calQ_m$
\item If $M \in \calQ_m$ then $(r_i\,p_j\,M) \in \calQ_m$ for $i \in \{1, \ldots, L\}$ and $j \in \{1, \ldots, m\}$
\item If $M \in \calQ_m$ then $(r_i\,(\lambda w.p_j\,w)\,M) \in \calQ_m$ for $i \in \{1, \ldots, L\}$ and $j \in \{1, \ldots, m\}$
\item If $M \in \calQ_m$ then $(z_\0\,N\,M) \in \calR_m$
\item If $M \in \calR_{m+1}$ then $(z_\star\,N\,(\lambda p_{m+1}.M)) \in \calR_m$
\end{itemize}
\end{definition}

\begin{remark}\label{rem:R1}
Terms in $\calR_1$ are inspired by inhabitants in a refinement~\cite[Lemma~4.4]{DudenhefnerR19} of Urzyczyn's undecidability result for intersection type inhabitation~\cite{Urzyczyn09}.
\end{remark}

Free variables occurring in terms in $\calQ_m$ and $\calR_m$ are assigned simple types according to the following type environment $\Gamma_m$.

\begin{definition}[Type Environment $\Gamma_m$]\label{def:Gamma}
For $m > 0$ let
\begin{align*}
\Gamma_m &:= \{ \begin{aligned}[t]
&z_\1 : \kappa, z_\0 : (\kappa \to \kappa) \to \kappa \to \kappa, z_\star : (\kappa \to \kappa) \to ((\kappa \to \kappa) \to \kappa) \to \kappa,\\
&p_1 : \kappa \to \kappa, \ldots, p_m : \kappa \to \kappa,\\
&r_1 : (\kappa \to \kappa) \to \kappa \to \kappa, \ldots, r_L : (\kappa \to \kappa) \to \kappa \to \kappa\}
\end{aligned}
\end{align*}
\end{definition}

Similarly to Example~\ref{xmp:no-ad-hoc}, we formulate typed terms (Definition~\ref{def:H}) and $\beta$-equivalence constraints characterizing members of $\calQ_m$ (Lemma~\ref{lem:ring2}) and $\calR_m$ (Lemma~\ref{lem:ring1}).

\begin{definition}[Typed Terms $H_\star, H_\0, H_R$]\label{def:H}
\begin{align*}
H_\star := &\lambda h.\lambda g.\lambda s_\0 s_\1 \ldots s_\K s_\$ s_\bullet s_\top s_\bot. \caseelse{g\,\delta_\bullet}{\$ \mapsto s_\$}{s_\bot}\\
H_\0 := &\lambda h.\lambda x. \lambda s_\0 s_\1 \ldots s_\K s_\$ s_\bullet s_\top s_\bot.\caseelse{x}{\1 \mapsto s_\$}{s_\bot}\\
H_R := &\lambda h.\lambda x. \lambda s_\0 s_\1 \ldots s_\K s_\$ s_\bullet s_\top s_\bot.\caseelse{h\,\pi_\top}{\bullet \mapsto \caseelse{x}{\1 \mapsto s_\1}{s_\bot} }{s_\bot}
\end{align*}
\[
\emptyset \vdash H_\star : \Gamma_m(z_\star) \qquad\quad
\emptyset \vdash H_\0 : \Gamma_m(z_\0) \qquad\quad
\emptyset \vdash H_R : \Gamma_m(r_i) \text{ for } i \in \{1, \ldots, L\}
\]
\end{definition}

We introduce substitutions $S_F$ and $S_H$ acting on the term variables $\{z_\star, z_\1, z_\0, r_1, \ldots, r_L\}$, which occur in terms in $\calQ_m$ and $\calR_m$.

\begin{definition}[Substitutions $S_F$, $S_H$]\label{def:SF_SH}
~\\
$\begin{array}{lllllll}
S_F(z_\star) := \lambda h.\lambda g.g\,I &\quad&
S_F(z_\1) := u &\quad&
S_F(z_\0) := \lambda h.I &\quad&
S_F(r_j) := I \text{ for } j \in {1, \ldots L}\\
S_H(z_\star) := H_\star &&
S_H(z_\1) := \pi_\1 &&
S_H(z_\0) := H_\0 &&
S_H(r_j) := H_R \text{ for } j \in {1, \ldots L}
\end{array}$
\end{definition}

%(* x_R x_p M or x_R (\w.x_p w) M *)
%(* rule application term or concluding term *)
%Inductive ring2 (l : nat) : term -> Prop :=
%  | ring2_intro x y M : ring2 l M -> x < length rules -> y < l -> ring2 l (app (app (var (x + 3 + l)) (var y)) M)
%  | ring2_intro_eta x y M : ring2 l M -> x < length rules -> y < l -> ring2 l (app (app (var (x + 3 + l)) (lam (app (var (S y)) (var 0)))) M)
%  | ring2_fin : ring2 l (var (S l)).

\begin{lemma}\label{lem:ring2}
%Lemma construct_ring2 M m :
%  normal_form M ->
%  stlc (Gamma_A m) M A ->
%  steps (subst (sigma_F m) M) (var m) ->
%  steps (subst (sigma_H m) M) (pi one) ->
%  ring2 m M.
For $m > 0$, if a term $M$ is in normal form such that $\Gamma_m \vdash M : \kappa$,\\
$S_F(M)[p_1 {\,:=\,} I, \ldots, p_m {\,:=\,} I] =_\beta u$, and
$S_H(M)[p_1 := \delta_\bullet, \ldots, p_m := \delta_\bullet] =_\beta \pi_{\1}$,
then $M \in \calQ_m$.
\end{lemma}

\begin{proof}[Proof\;\coq{L1687}.]
Induction on the size of $M$ and case analysis of the normal form.
\end{proof}

%(* x_star N (\x_p.M) *)
%(* word expansion term or init rule application term *)
%Inductive ring1 (l : nat) : term -> Prop :=
%  | ring1_intro M N : ring1 (S l) M -> ring1 l (apps (var l) [N; lam M])
%  | ring1_init M N : ring2 l M -> ring1 l (apps (var (2 + l)) [N; M]).

\begin{lemma}\label{lem:ring1}
%Lemma construct_ring1 M m :
%  normal_form M ->
%  stlc (Gamma_A m) M A ->
%  steps (subst (sigma_F m) M) (var m) ->
%  steps (subst (sigma_H m) M) (pi dollar)  ->
%  ring1 m M.
For $m > 0$, if a term $M$ is in normal form such that $\Gamma_m \vdash M : \kappa$,\\
$S_F(M)[p_1 {\,:=\,} I, \ldots, p_m {\,:=\,} I] =_\beta u$, and
$S_H(M)[p_1 := \delta_\bullet, \ldots, p_m := \delta_\bullet] =_\beta \pi_{\$}$,
then $M \in \calR_m$.
\end{lemma}

\begin{proof}[Proof\;\coq{L1825}.]
Induction on the size of $M$, case analysis of the normal form, and Lemma~\ref{lem:ring2}.
\end{proof}

As a consequence of the above Lemma~\ref{lem:ring1}, the following Theorem~\ref{thm:shape} presents $\beta$-equivalence constraints which suffice to restrict the shape of terms under consideration.

\begin{theorem}\label{thm:shape}
%Lemma solution_shape (M : term) :
%  normal_form M ->
%  (* correctly typed closed term *)
%  stlc [] M (arrs (repeat A_0R (length rules + 1) ++ [A; A_star; arr A A]) A) ->
%  steps (apps M (repeat F_R (length rules) ++ [F_0; var 0; F_star; (lam (var 0))])) (var 0) ->
%  steps (apps M (repeat H_R (length rules) ++ [H_0; H_1; H_star; delta bullet])) (pi dollar) ->
%  exists N, M = lams (length rules + 4) N /\ ring1 1 N.
  
If a term $M$ is in normal form such that\\$\emptyset \vdash M : \Gamma_1(r_1) \to \cdots \to \Gamma_1(r_L) \to \Gamma_1(z_\0) \to \Gamma_1(z_\1) \to \Gamma_1(z_\star) \to \Gamma_1(p_1) \to \kappa$,\\
$M\,I \ldots I\,(\lambda h.I)\,u\,(\lambda h.\lambda g.g\,I)\,I =_\beta u$, and
$M\,H_R \ldots H_R\,H_\0\,\pi_\1\,H_\star\,\delta_\bullet =_\beta \pi_{\$}$,\\
then $M = \lambda r_1 \ldots r_L.\lambda z_\0 z_\1 z_\star p_1.N$ for some term $N$ such that $N \in \calR_1$.
\end{theorem}

\begin{proof}[Proof\;\coq{L1932}.]
Induction on the size of $M$, case analysis of the normal form, and Lemma~\ref{lem:ring1}.
\end{proof}

\newpage

\begin{example}\label{xmp:H}
Assume $\frakR = \{\0\0 \Rightarrow \2\2, \0\2 \Rightarrow \1\1, \2\0 \Rightarrow \1\1\}$ over the alphabet $\{\0,\1,\2\}$ from Example~\ref{xmp:ssts}.
Let $N := r_1\,p_2\,(r_2\,p_1\,(r_3\,p_3\,z_\1))$ and
$M := z_\star\,p_1\,(\lambda p_2.z_\star\,p_2\,(\lambda p_3.z_\0\,p_3\,N))$.
We have $N \in \calQ_3$ and $M \in \calR_1$.
In congruence with Theorem~\ref{thm:shape} we have:\\
$\begin{array}{ll}
(\lambda r_1 r_2 r_3.\lambda z_\0 z_\1 z_\star p_1.M)\,I\,I\,I\,(\lambda h.I)\,u\,(\lambda h.\lambda g.g\,I)\,I &=_\beta u\\
(\lambda r_1 r_2 r_3.\lambda z_\0 z_\1 z_\star p_1.M)\,H_R\,H_R\,H_R\,H_\0\,\pi_\1\,H_\star\,\delta_\bullet &=_\beta \pi_{\$}
\end{array}$

While Theorem~\ref{thm:shape} only establishes \enquote{well-formedness}, the term $M$ has an intended meaning.
Specifically, an initial word of length $2$ is expanded twice (using $z_\star$) to a word of length $4$ and initialized to $\0$s (using $z_\0$).
The introduced variables $p_2$ and $p_3$ are used to address positions in the longer word.
The intended meaning of $N$ is that the first rule (using $r_1$) is applied at position $2$ (using $p_2$), followed by the second rule at position $1$ and third rule at position $3$ accordingly.
The resulting word contains only $\1$s (indicated by $z_\1$).
Overall, this corresponds to $\0\0\0\0 \Rightarrow_\frakR \0\2\2\0 \Rightarrow_\frakR \1\1\2\0 \Rightarrow_\frakR \1\1\1\1$.

\end{example}

Having only \enquote{well-formed} terms to consider (cf. Example~\ref{xmp:ad-hoc} and Example~\ref{xmp:no-ad-hoc}), we can focus on the functional part of rewriting.

\subsection*{Semantic Constrains}

We formulate typed terms (Definition~\ref{def:G}) and $\beta$-equivalence constraints characterizing word expansion (Lemma~\ref{lem:R_ssts_sem}) and rewriting (Lemma~\ref{lem:Q_ssts_sem}).
The presented terms are programs which realize the intended meaning (Example~\ref{xmp:H}) of \enquote{well-formed} terms in $\calQ_m$ and $\calR_m$.
Specifically, $G_\star$ realizes word expansion, $G_\0$ realizes initialization with $\0$s, $G_{ab \Rightarrow cd}$ realizes rule application, and $G_j^i$ addresses position $i$ for rule application at position $j$.

\begin{definition}[Typed Terms $G_\star$, $G_\0$, $G_{ab \Rightarrow cd}$, $G_i^j$]
\label{def:G}
\begin{align*}
G_\star := &\lambda h.\lambda g.\lambda s_\0 s_\1 \ldots s_\K s_\$ s_\bullet s_\top s_\bot.\case{h\,\pi_\top}{s_\bot\\
&\hspace{1.0em} \mid \bullet \mapsto \caseelse{g\,\delta_\bullet}{\0 \mapsto s_\0 \mid \$ \mapsto \caseelse{g\,\delta_\0}{\1 \mapsto s_\$}{s_\bot}}{s_\bot}\\
&\hspace{1.0em} \mid \0 \mapsto \caseelse{g\,\delta_\1}{\0 \mapsto s_\1}{s_\bot}\\
&\hspace{1.0em} \mid \1 \mapsto \caseelse{g\,\delta_\bullet}{\0 \mapsto s_\0}{s_\bot}}\\
G_\0 := &\lambda h.\lambda x. \lambda s_\0 s_\1 \ldots s_\K s_\$ s_\bullet s_\top s_\bot.\case{h\,\pi_\top}{s_\bot\\
&\quad\mid \bullet \mapsto \caseelse{x}{\0 \mapsto s_\0 \mid \1 \mapsto s_\$}{s_\bot}\\
&\quad\mid\0 \mapsto \caseelse{x}{\0 \mapsto s_\1}{s_\bot}\\
&\quad\mid\1 \mapsto \caseelse{x}{\0 \mapsto s_\0 }{s_\bot}}\\
G_{ab \Rightarrow cd} := &\lambda h.\lambda x.\lambda s_\0 s_\1 \ldots s_\K s_\$ s_\bullet s_\top s_\bot.\case{h\,\pi_\top}{s_\bot\\
&\quad\mid\bullet \mapsto x\,s_\0\,s_\1\, \ldots s_\K\, s_\$\, s_\bullet\, s_\top\, s_\bot\\
&\quad\mid\0 \mapsto \caseelse{x}{d \mapsto s_b}{s_\bot}\\
&\quad\mid\1 \mapsto \caseelse{x}{c \mapsto s_a}{s_\bot}}\\
G_j^i := &\begin{cases}
\delta_\1 & \text{if } i = j\\
\delta_\0 & \text{if } i = j + 1\\
\delta_\bullet & \text{else}
\end{cases}
\end{align*}
\[\emptyset \vdash G_\star : \Gamma_m(z_\star) \qquad\quad
\emptyset \vdash G_\0 : \Gamma_m(z_\0) \qquad\quad
\emptyset \vdash G_{ab \to cd} : \Gamma_m(r_i) \text{ for } i \in \{1, \ldots, L\}\]
\end{definition}

Similarly to substitutions $S_F$ and $S_H$, we introduce the following substitution $S_G$.

\begin{definition}[Substitution $S_G$]\label{def:S_G}
\[S_G(z_\star) := G_\star \qquad
S_G(z_\1) := \pi_\1 \qquad
S_G(z_\0) := G_\0 \qquad
S_G(r_j) := G_{R_j} \text{ for } j \in {1, \ldots L}\]
\end{definition}

The following Example~\ref{xmp:rule} illustrates application of a term $G_{ab \Rightarrow cd}$.

\begin{example}\label{xmp:rule}
Consider the rule $bc \Rightarrow b'c'$ applied at position $2$ in order to rewrite the word $abcd$ to $ab'c'd$. Accordingly, we have:
\begin{description}
\item[Position $1$:] $G_{bc \Rightarrow b'c'}\,G_2^1\,\pi_a =_\beta \pi_a$
\item[Position $2$:] $G_{bc \Rightarrow b'c'}\,G_2^2\,\pi_{b'} =_\beta \pi_b$
\item[Position $3$:] $G_{bc \Rightarrow b'c'}\,G_2^3\,\pi_{c'} =_\beta \pi_c$
\item[Position $4$:] $G_{bc \Rightarrow b'c'}\,G_2^4\,\pi_d =_\beta \pi_d$
\end{description}
\end{example}

The above observation is generalized for terms in $\calQ_m$ in the following Lemma~\ref{lem:Q_ssts_sem}.

%  m > 0 ->
%  length v = S m ->
%  ring2 m M ->
%  stlc (Gamma_A m) M A ->
%  steps (subst (sigma_G m 0) M) (pi one) ->
%  Forall2 (fun i a => sym a < n /\ steps (subst (sigma_G m (S i)) M) (pi (sym a))) (seq 0 (S m)) v ->
%  SSTS.multi_step rules v (repeat 1 (S m)).

\begin{lemma}\label{lem:Q_ssts_sem}
For $m > 0$ let $a_1, \ldots, a_{m + 1} \in \{\0, \1, \ldots, \K\}$, and $M \in \calQ_m$. If $\Gamma_m \vdash M : \kappa$,\\
$S_G(M)[p_1 := G_1^0, \ldots, p_m := G_m^0] =_\beta \pi_\1$, and
$S_G(M)[p_1 := G_1^i, \ldots, p_m := G_m^i] =_\beta \pi_{a_i}$ for $i \in \{1, \ldots, m+1\}$,
then $a_1 \ldots a_{m + 1} \Rightarrow_\frakR^* \1^{m+1}$.
\end{lemma}

\begin{proof}[Proof\;\coq{L2106}.]
Induction on the size of $M$ and case analysis using Definition~\ref{def:ring}.
\end{proof}

The following Example~\ref{xmp:G_Q} builds upon the previous Example~\ref{xmp:H} and illustrates the intended meaning (rewriting $\0$s to $\1$s) of a \enquote{well-formed} example term in $\calQ_3$. %under the substitution $S_G$.

\begin{example}\label{xmp:G_Q}
Assume $\frakR = \{\0\0 \Rightarrow \2\2, \0\2 \Rightarrow \1\1, \2\0 \Rightarrow \1\1\}$ over the alphabet $\{\0,\1,\2\}$, and consider the term $N = r_1\,p_2\,(r_2\,p_1\,(r_3\,p_3\,z_\1))$ from Example~\ref{xmp:H}.
Replacing $G_j^i$ accordingly for $i \in \{0, \ldots, 5\}$ and $j \in \{1, 2, 3\}$, we have the following $\beta$-equivalences $(0)$ -- $(4)$.
$\begin{array}{lll}
(0) &\quad &S_G(N)[p_1 := \delta_\bullet, p_2 := \delta_\bullet, p_3 := \delta_\bullet] =_\beta \pi_\1 \\
(1) &\quad &S_G(N)[p_1 := \delta_\1, p_2 := \delta_\bullet, p_3 := \delta_\bullet] =_\beta \pi_\0\\
(2) &\quad &S_G(N)[p_1 := \delta_\0, p_2 := \delta_\1, p_3 := \delta_\bullet] =_\beta \pi_\0\\
(3) &\quad &S_G(N)[p_1 := \delta_\bullet, p_2 := \delta_\0, p_3 := \delta_\1] =_\beta \pi_\0\\
(4) &\quad &S_G(N)[p_1 := \delta_\bullet, p_2 := \delta_\bullet, p_3 := \delta_\0] =_\beta \pi_\0
\end{array}$

In accordance with Lemma~\ref{lem:Q_ssts_sem}, we have that $\0^4 \Rightarrow_\frakR^* \1^4 $.
Equivalences $(1)$ -- $(4)$ witness the particular rewriting steps at positions $1$ -- $4$ (cf.~Example~\ref{xmp:H} and Example~\ref{xmp:rule}).
\end{example}

Complementarily to word rewriting, the following Lemma~\ref{lem:R_ssts_sem} characterizes word expansion and initialization with $\0$s.

%  ring1 m N ->
%  stlc (Gamma_A m) N A ->
%  steps (subst (sigma_G m 0) N) (pi dollar) ->
%  steps (subst (sigma_G m 1) N) (pi one) ->
%  Forall (fun i => steps (subst (sigma_G m (S (S i))) N) (pi zero)) (seq 0 m) ->
%  exists M k, ring2 (k + m) M /\
%    stlc (Gamma_A (k + m)) M A /\
%    steps (subst (sigma_G (k + m) 0) M) (pi one) /\
%    steps (subst (sigma_G (k + m) 1) M) (pi zero) /\
%    Forall (fun i => steps (subst (sigma_G (k + m) (S (S i))) M) (pi zero)) (seq 0 (k+m)).

\begin{lemma}\label{lem:R_ssts_sem}
If $M \in \calR_1$ such that $\Gamma_1 \vdash M : \kappa$,\\
$S_G(M)[p_1 := \delta_\bullet] =_\beta \pi_\$$,
$S_G(M)[p_1 := \delta_\1] =_\beta \pi_\0$, and
$S_G(M)[p_1 := \delta_\0] =_\beta \pi_\1$,\\
then there exists an $m > 0$ and an $N \in \calQ_m$ such that $\Gamma_m \vdash N : \kappa$,\\
$S_G(N)[p_1 := G_1^0, \ldots, p_m := G_m^0] =_\beta \pi_\1$, and
$S_G(N)[p_1 := G_1^i, \ldots, p_m := G_m^i] =_\beta \pi_\0$ for $i \in \{1, \ldots, m+1\}$.
\end{lemma}

\begin{proof}[Proof\;\coq{L2017}.]
Considering the general case $M \in \calR_{m'}$ for $m' > 0$, induction on the size of $M$ and case analysis using Definition~\ref{def:ring}.
\end{proof}

The following Example~\ref{xmp:G_R} complements the previous Example~\ref{xmp:G_Q} and illustrates the intended meaning (word expansion and initialization with $\0$s) of a \enquote{well-formed} term in $\calR_1$.

\begin{example}\label{xmp:G_R}
Assume $\frakR = \{\0\0 \Rightarrow \2\2, \0\2 \Rightarrow \1\1, \2\0 \Rightarrow \1\1\}$ over the alphabet $\{\0,\1,\2\}$, and consider the terms
$M_1 := z_\star\,p_1\,(\lambda p_2.M_2)$, $M_2 := z_\star\,p_2\,(\lambda p_3.M_3)$,
$M_3 := z_\0\,p_3\,N$, and $N := r_1\,p_2\,(r_2\,p_1\,(r_3\,p_3\,z_\1))$ from Example~\ref{xmp:G_Q}.
Proceeding bottom up, we have $M_3 \in \calR_3$ and the following $\beta$-equivalences hold:\\
$\begin{array}{l}
S_G(M_3)[p_1 := \delta_\bullet, p_2 := \delta_\bullet, p_3 := \delta_\bullet] =_\beta \pi_\$\\
S_G(M_3)[p_1 := \delta_\1, p_2 := \delta_\bullet, p_3 := \delta_\bullet] =_\beta \pi_\0\\
S_G(M_3)[p_1 := \delta_\0, p_2 := \delta_\1, p_3 := \delta_\bullet] =_\beta \pi_\0\\
S_G(M_3)[p_1 := \delta_\bullet, p_2 := \delta_\0, p_3 := \delta_\1] =_\beta \pi_\0\\
S_G(M_3)[p_1 := \delta_\bullet, p_2 := \delta_\bullet, p_3 := \delta_\0] =_\beta \pi_\1
\end{array}$\\
Additionally, $M_2 \in \calR_2$, $M_1 \in \calR_1$, and the following $\beta$-equivalences hold:\\
$\begin{array}{l}
S_G(M_1)[p_1 := \delta_\bullet] =_\beta \pi_\$\\
S_G(M_1)[p_1 := \delta_\1] =_\beta \pi_\0\\
S_G(M_1)[p_1 := \delta_\0] =_\beta \pi_\1
\end{array}$
\qquad
$\begin{array}{l}
S_G(M_2)[p_1 := \delta_\bullet, p_2 := \delta_\bullet] =_\beta \pi_\$\\
S_G(M_2)[p_1 := \delta_\1, p_2 := \delta_\bullet] =_\beta \pi_\0\\
S_G(M_2)[p_1 := \delta_\0, p_2 := \delta_\1] =_\beta \pi_\0\\
S_G(M_2)[p_1 := \delta_\bullet, p_2 := \delta_\0] =_\beta \pi_\1
\end{array}$

In combination with the previous Example~\ref{xmp:G_Q}, the term $M_1 \in \calR_1$ represents word expansion up to length $4$, followed by initialization with $\0$s, and rewriting to $\1$s.
\end{example}

Next, we combine syntactic and semantic constraints in the following key Lemma~\ref{lem:ssts_to_constr}.

\begin{lemma}\label{lem:ssts_to_constr}
There exists an $n \in \bbN$ such that $\0^{n+1} \Rightarrow_\frakR^* \1^{n+1}$ iff
there exists a term $M$ in normal form, such that the following conditions hold:\\
$\emptyset \vdash M : \Gamma_1(r_1) \to \cdots \to \Gamma_1(r_L) \to \Gamma_1(z_\0) \to \Gamma_1(z_\1) \to \Gamma_1(z_\star) \to \Gamma_1(p_1) \to \kappa$,\\
$\begin{array}{ll}
M\,I \ldots I\,(\lambda h.I)\,u\,(\lambda h.\lambda g.g\,I)\,I &=_\beta u,\\
M\,H_R \ldots H_R\,H_\0\,\pi_\1\,H_\star\,\delta_\bullet &=_\beta \pi_{\$},\\
M\,G_{R_1} \ldots G_{R_L}\,G_\0\,\pi_\1\,G_\star\,\delta_\bullet &=_\beta \pi_{\$},\\
M\,G_{R_1} \ldots G_{R_L}\,G_\0\,\pi_\1\,G_\star\,\delta_\1 &=_\beta \pi_{\0},\\
M\,G_{R_1} \ldots G_{R_L}\,G_\0\,\pi_\1\,G_\star\,\delta_\0 &=_\beta \pi_{\1}.
\end{array}$
\end{lemma}

\begin{proof}[Proof\;\coq{L2758}.]
The direction from left to right proceeds in two steps.
First, by induction on the number of rewriting steps we construct a term $N \in \calQ_n$ (easy converse of Lemma~\ref{lem:Q_ssts_sem}).
Second, by induction on $n$ we construct a term $M' \in \calR_1$ containing $N \in \calQ_n$ as a subterm (easy converse of Lemma~\ref{lem:R_ssts_sem}).
Then, the solution is $M := \lambda r_1 \ldots r_L.\lambda z_\0 z_\1 z_\star p_1.M'$.

The direction from right to left is proceeds in two steps.
First, by Theorem~\ref{thm:shape} we have $\lambda r_1 \ldots r_L.\lambda z_\0 z_\1 z_\star p_1.M'$ for some $M' \in \calR_1$.
Second, by Lemma~\ref{lem:R_ssts_sem} and Lemma~\ref{lem:Q_ssts_sem} we have $\0^{n+1} \Rightarrow_\frakR^* \1^{n+1}$ for some $n > 0$.
\end{proof}

Finally, we present constraints from the above Lemma~\ref{lem:ssts_to_constr} as an instance $F_\frakR\,\mathsf{X} =_\beta N_\frakR$ of Higher-order $\beta$-Matching.
This constitutes the main result of the present work.

\begin{theorem}\label{thm:ssts_to_hom}
Problem $\0^+ \Rightarrow_\mathfrak{R}^* \1^+$ (Problem~\ref{prb:ssts01}) many-one reduces to Higher-order $\beta$-Matching (Problem~\ref{prb:hom}).
\end{theorem}

\begin{proof}[Proof\;\coq{L2880}.]
Given a simple semi-Thue system $\frakR = \{R_1, \ldots, R_L\}$ due to Lemma~\ref{lem:ssts_to_constr} there exists an $n \in \bbN$ such that $\0^{n+1} \Rightarrow_\frakR^* \1^{n+1}$ iff the instance $F_\frakR\,\mathsf{X} =_\beta N_\frakR$ of higher-order $\beta$-matching is solvable, where
\begin{itemize}
\item $F_\frakR := \lambda x.\lambda y.y \begin{array}[t]{l}
(\lambda u.x\,\underbracket{I \ldots I}_{L \text{ times}}\,(\lambda h.I)\,u\,(\lambda h.\lambda g.g\,I)\,I)\\
(x\,\underbracket{H_R \ldots H_R}_{L \text{ times}}\,H_\0\,\pi_\1\,H_\star\,\delta_\bullet)\\
(x\,G_{R_1} \ldots G_{R_L}\,G_\0\,\pi_{1}\,G_\star\,\delta_\bullet)\\
(x\,G_{R_1} \ldots G_{R_L}\,G_\0\,\pi_{1}\,G_\star\,\delta_\1)\\
(x\,G_{R_1} \ldots G_{R_L}\,G_\0\,\pi_{1}\,G_\star\,\delta_\0)
\end{array}$
\item $N_\frakR := \lambda y.y\,(\lambda u.u)\,\pi_\$\,\pi_\$\,\pi_\0\,\pi_\1$
\item $\sigma_\frakR := \Gamma_1(r_1) \to \cdots \to \Gamma_1(r_L) \to \Gamma_1(z_\0) \to \Gamma_1(z_\1) \to \Gamma_1(z_\star) \to \Gamma_1(p_1) \to \kappa$
\item $\tau_\frakR := ((\kappa \to \kappa) \to \kappa \to \kappa \to \kappa \to \kappa \to \ga) \to \ga$
\item $\emptyset \vdash F_\frakR : \sigma_\frakR \to \tau_\frakR$
\item $\emptyset \vdash N_\frakR : \tau_\frakR$\qedhere
\end{itemize}
\end{proof}

\begin{theorem}\label{thm:hom_undec}
Higher-order $\beta$-Matching (Problem~\ref{prb:hom}) is undecidable.
\end{theorem}

\begin{proof}[Proof\;\coqextra{LambdaCalculus/HOMatching\_undec.v\#L16}]
By reduction from the undecidable Problem $\0^+ \Rightarrow_\mathfrak{R}^* \1^+$ (Theorem~\ref{thm:ssts_undec} and Theorem~\ref{thm:ssts_to_hom}).
\end{proof}

We conclude the technical presentation with the following observation:
the presented approach reducing Problem $\0^+ \Rightarrow_\mathfrak{R}^* \1^+$ to Higher-order $\beta$-matching is easily transferred to intersection type inhabitation and $\lambda$-definability.

The following Remark~\ref{rem:G} shows the structure of the underlying finite model with respect to the present construction.

%\begin{remark}\label{rem:H}
%Terms in the above Definition~\ref{def:H} realize certain finite functions as follows.
%\begin{itemize}
%\item $H_\star$ realizes a member of the family $\left(\omega \mapsto ((\top \mapsto \bullet) \mapsto \$) \mapsto \$ \right)$.
%\item $H_\0$ realizes a member of the family $(\omega \mapsto (\1 \mapsto \$))$.
%\item $H_R$ realizes a member of the family $((\top \mapsto \bullet) \mapsto (\1 \mapsto \1))$.
%\end{itemize}
%\end{remark}

\begin{remark}\label{rem:G}
Terms in Definition~\ref{def:G} realize certain finite functions as follows.
\begin{itemize}
\item $G_\star$ realizes a member of the family ${\small\left(\begin{array}{l}
(\top \mapsto \bullet) \mapsto ((\top \mapsto \bullet) \mapsto \0) \mapsto \0)\\
(\top \mapsto \bullet) \mapsto \left(\left(\begin{array}{l}
(\top \mapsto \bullet) \mapsto \$\\
(\top \mapsto \0) \mapsto \1
\end{array}\right) \mapsto \$\right)\\
(\top \mapsto \0) \mapsto ((\top \mapsto \1) \mapsto \0) \mapsto \1)\\
(\top \mapsto \1) \mapsto ((\top \mapsto \bullet) \mapsto \0) \mapsto \0)
\end{array}\right)}$.
\item $G_\0$ realizes a member of the family ${\small\left(\begin{array}{l}
(\top \mapsto \bullet) \mapsto (\0 \mapsto \0)\\
(\top \mapsto \bullet) \mapsto (\1 \mapsto \$)\\
(\top \mapsto \0) \mapsto (\0 \mapsto \1)\\
(\top \mapsto \1) \mapsto (\0 \mapsto \0)
\end{array}\right)}$.
\item $G_{ab \Rightarrow cd}$ realizes a member of the family ${\small\left(\begin{array}{l}
(\top \mapsto \1) \mapsto (c \mapsto a)\\
(\top \mapsto \0) \mapsto (d \mapsto b)
\end{array}\right)}$ such that\\
$G_{ab \Rightarrow cd} \, \delta_\bullet \, \pi_i =_\beta \pi_i$ for $i \in \calA$.
\end{itemize}
\end{remark}

The above families finite function specifications are immediately represented by intersection types.
Let us state in the following Proposition~\ref{prop:uniform} the relationship between simple semi-Thue system rewriting, Higher-order $\beta$-matching, $\lambda$-definability, and intersection type inhabitation.

\begin{proposition}\label{prop:uniform}
Given a simple semi-Thue system $\frakR$, one can construct simply typed terms $\emptyset \vdash F_\frakR : \sigma_\frakR \to \tau_\frakR$ and $\emptyset \vdash N_\frakR : \tau_\frakR$, an intersection type $T_\frakR$, and a finite function $\calF_\frakR$ such that the following statements are equivalent:
\begin{enumerate}
\item There exists an $n \in \bbN$ such that $\0^{n+1} \Rightarrow_\frakR^* \1^{n+1}$.
\item The instance $F_\frakR\,\mathsf{X} =_\beta N_\frakR$ of Higher-order $\beta$-Matching is solvable.
\item The intersection type $T_\frakR$ is inhabited.
\item The finite function $\calF_\frakR$ is $\lambda$-definable.
\end{enumerate}
\end{proposition}

Of course, $(1) \Rightarrow (3)$ can be concluded from undecidability of intersection type inhabitation~\cite{Urzyczyn09} and $(1) \Rightarrow (4)$ from undecidability of $\lambda$-definability~\cite{loader2001undecidability}.
The presented approach shows $(1) \Rightarrow (2)$, and we make the following two observations.
First, referring to Remark~\ref{rem:R1}, the approach is inspired by and easily adapted to show $(1) \Rightarrow (3)$, such that the inhabitant is essentially a member of $\calR_1$.
Second, based on Remark~\ref{rem:G}, the approach can be adapted to show $(1) \Rightarrow (4)$, such that the realizer is essentially a member of $\calR_1$.
This is supported by the known equivalence between (a fragment of) intersection type inhabitation and $\lambda$-definability~\cite{SalvatiMGB12}.

\newpage

\section{Mechanization}\label{sec:mech}
\lstset{
comment=[l]{(*},
basicstyle=\ttfamily\footnotesize,
keywordstyle=\color{blue},
morekeywords={Inductive,Type,Theorem,Definition,exists,fun},
commentstyle=\color{OliveGreen},
backgroundcolor=\color{yellow!5},
framerule=0.4pt,
frame=single,
inputencoding=utf8,
extendedchars=false,}

This section provides a brief overview over the mechanization of undecidability of Higher-order $\beta$-Matching (Theorem~\ref{thm:hom_undec}) using the Coq proof assistant~\cite{Coq_2023}.
The mechanization is axiom-free and spans approximately $4000$ lines of code, consisting of the following parts:
\begin{itemize}
\item \texttt{HOMatching.v} contains definitions of the simply typed $\lambda$-calculus~\coqextra{LambdaCalculus/HOMatching.v\#L31} and Higher-order $\beta$-matching~\coqextra{LambdaCalculus/HOMatching.v\#L37}.
\item \texttt{Util/stlc\_facts.v} and \texttt{Util/term\_facts.v} contain basic properties of the simply typed $\lambda$-calculus, such as confluence of $\beta$-reduction~\coqextra{LambdaCalculus/Util/term\_facts.v\#L1056}, substitution lemmas~\coqextra{LambdaCalculus/Util/stlc\_facts.v\#L100}, and type preservation properties~\coqextra{LambdaCalculus/Util/stlc\_facts.v\#L116}.
\item \texttt{Reductions/SSTS01\_to\_HOMbeta.v} contains the reduction from Problem $\0^+ \Rightarrow_\mathfrak{R}^* \1^+$ to Higher-order $\beta$-Matching~\coq{L2880}.
\item \texttt{HOMatching\_undec.v} contains the undecidability result for Higher-order $\beta$-Matching~\coqextra{LambdaCalculus/HOMatching\_undec.v\#L16}.
\end{itemize}

The simple type system \texttt{stlc} is mechanized in \texttt{HOMatching.v}, borrowing the existing term definitions from the library~\coqextra{L/L.v\#L8}, for which variable binding is addressed via the unscoped de Bruijn approach~\cite{deBruijn72}.
The proposition \texttt{stlc~Gamma~M~t} mechanizes that the term \texttt{M} is assigned the simple type~\texttt{t} in the simple type environment \texttt{Gamma}.
\begin{lstlisting}[mathescape]
Inductive ty : Type :=
  | atom (* type variable *)
  | arr (s t : ty). (* function type *)

Inductive term : Type :=
  | var (n : nat) : term (* term variable *)
  | app (s : term) (t : term) : term (* application *)
  | lam (s : term). (* abstraction *)

Inductive stlc (Gamma : list ty) : term -> ty -> Prop :=
  | stlc_var x t : nth_error Gamma x = Some t ->
      stlc Gamma (var x) t (* variable rule *)
  | stlc_app M N s t : stlc Gamma M (arr s t) -> stlc Gamma N s ->
      stlc Gamma (app M N) t (* application rule *)
  | stlc_lam M s t : stlc (cons s Gamma) M t ->
      stlc Gamma (lam M) (arr s t). (* abstraction rule *)
\end{lstlisting}

Higher-order $\beta$-Matching is mechanized as the predicate \texttt{HOMbeta}: given terms \texttt{F} of type \texttt{arr s t} and \texttt{N} of type \texttt{t}, is there a simply typed term \texttt{M} of type \texttt{s} such that \texttt{app F M} is $\beta$-equivalent (reflexive, symmetric, transitive closure of \texttt{step}) to \texttt{N}?
\begin{lstlisting}[mathescape]
Definition HOMbeta : { '(s, t, F, N) : (ty * ty * term * term) 
  | stlc nil F (arr s t) /\ stlc nil N t } -> Prop :=
    fun '(exist _ (s, t, F, N) _) =>
      exists (M : term), stlc nil M s /\
        clos_refl_sym_trans term step (app F M) N.
\end{lstlisting}

The proposition \lstinline|undecidable HOMbeta|~\coqextra{LambdaCalculus/HOMatching\_undec.v\#L16} mechanizes the undecidability of the predicate \texttt{HOMbeta}, relying on the following library definition~\cite{CLUP20}.
A predicate \texttt{p} is undecidable, if existence of a computable decider for \texttt{p} implies recursive co-enumerability of the (Turing machine) Halting Problem.
\begin{lstlisting}[mathescape]
Definition undecidable {X} (p : X -> Prop) :=
  decidable p -> enumerable (complement SBTM_HALT).
\end{lstlisting}
Since the Halting Problem is recursively enumerable, decidability of \texttt{p} would imply decidability of the Halting Problem.

\section{Conclusion}\label{sec:concl}
There are three interdependent aspects of the proof of \texttt{Theorem nitlc\_type\_inference} which highlight the utility of the Coq proof assistant.
\begin{itemize}
\item The definition of the -reduction (\Cref{def:redkp}) allows for an expansion lemma.
\item The inductive hypothesis for the expansion lemma (cf.~\Cref{lem:redk-expansion-u}) is chosen carefully.
\item The particular inductive proof involves extensive, nested case analyses for the chosen definition and inductive hypothesis.
\end{itemize}
In all three aspects the development of the proof was guided by the proof assistant:
the technical details listed by the tool motivated the particular definition of the -reduction.
In fact, the proof was developed via interaction with the mechanized statement 
prior to being transcribed into a traditional written format.

\section{Appendix}


\begin{example}~
\begin{itemize}
\item specification $A := \big((1 \to 2) \wedge (2 \to 3) \wedge (3 \to 1)\big) \to 1 \to 3$
\item universe elements
\begin{itemize}
\item $\pi_1 := \lambda xyz.x$
\item $\pi_2 := \lambda xyz.y$
\item $\pi_3 := \lambda xyz.z$
\item $\emptyset \vdash \pi_i : \sigma_\calU$ where $\sigma_\calU := \ga \to \ga \to \ga \to \ga$
\end{itemize}
\item permutation $G := \lambda h.\lambda xyz.h\,y\,z\,x$
\begin{itemize}
\item $G\,\pi_1 \twoheadrightarrow_\beta \pi_2$
\item $G\,\pi_2 \twoheadrightarrow_\beta \pi_3$
\item $G\,\pi_3 \twoheadrightarrow_\beta \pi_1$
\item[$\leadsto$] $G$ realizes specification $(1 \to 2) \wedge (2 \to 3) \wedge (3 \to 1)$
\item $\emptyset \vdash G : \sigma_\calU \to \sigma_\calU$
\end{itemize}
\item matching constraint $X\,G\,\pi_1 =_\beta \pi_3$
\item \emph{well-behaved} solution %$X \mapsto \tm{\lambda g.\lambda h.g\,(g\,h)}$
\begin{itemize}
\item $X\,G\,\pi_1 \mapsto \big(\lambda g.\lambda h.g\,(g\,h)\big)\,G\,\pi_1
\twoheadrightarrow_\beta G\,(G\,\pi_1) \twoheadrightarrow_\beta \pi_3$
\end{itemize}
\item \emph{troubling} solution %$X \mapsto \tm{\lambda g.\lambda h.\pi_\li{3}}$
\begin{itemize}
\item $X\,G\,\pi_1 \mapsto \big(\lambda g.\lambda h.\pi_3\big)\,G\,\pi_1
\twoheadrightarrow_\beta \pi_3$
\end{itemize}
\item another \emph{troubling} solution %$X \mapsto \tm{\lambda g.\lambda h.\lambda xyz.h\,z\,z\,z}$
\begin{itemize}
\item $X\,G\,\pi_1 \mapsto \big(\lambda g.\lambda h.\lambda xyz.h\,z\,z\,z\big)\,G\,\pi_1
\twoheadrightarrow_\beta \lambda xyz.\pi_1\,z\,z\,z \twoheadrightarrow_\beta \pi_3$
\end{itemize}
\end{itemize}


\begin{itemize}
\item \emph{semantic} constraint (1) $X\,G\,\pi_1 =_\beta \pi_3$
\item \emph{syntactic} constraint (2) $X\,I\,u =_\beta u$
\item well-behaved solutions for (1) solve (2)
\begin{itemize}
\item $X\,I\,u \mapsto \big(\lambda g.\lambda h.g\,(g\,h)\big)\,I\,u
\twoheadrightarrow_\beta I\,(I\,u) \twoheadrightarrow_\beta u$
\end{itemize}
\item troubling solutions for (1) do \emph{not} solve (2)
\begin{itemize}
\item $X\,I\,u \mapsto \big(\lambda g.\lambda h.\pi_3\big)\,I\,u
\twoheadrightarrow_\beta \pi_3 \not=_\beta u$
\item $X\,I\,u \mapsto \big(\lambda g.\lambda h.\lambda xyz.h\,z\,z\,z\big)\,I\,u
\twoheadrightarrow_\beta \lambda xyz.u\,z\,z\,z \not=_\beta u$
\end{itemize}
\item combined matching instance $\big(\lambda x.\lambda y.y\,(x\,G\,\pi_1)\,(\lambda u.x\,I\,u)\big)\,X = \lambda y.y\,\pi_3\,(\lambda u.u)$
\end{itemize}
\end{example}



\begin{remark}~
\begin{itemize}
\setlength\itemsep{0.1em}
\item syntactic constraint restricts the number of $\lambda$-abstractions in solutions
\item solutions are \emph{not} $\eta$-long wrt. $(\sigma_\calU \to \sigma_\calU) \to \sigma_\calU \to \sigma_\calU$
\item solutions are inhabitants of intersection type $A$
%\item syntactic constraints don't work well with $\eta$-equality
\end{itemize}
\end{remark}

\begin{itemize}
\item example $\calR := \{00 \Rightarrow 21, 02 \Rightarrow 11\}$
\item atoms $\{\bot, \top, \bullet, \dag, 0, 1, 2 \}$
%\item universe $\calU := \{\tm{\pi}_\bot, \tm{\pi}_\top, \tm{\pi_\xt{\bullet}}, \tm{\pi_\li{0}}, \tm{\pi_\li{1}}, \tm{\pi_\li{0}}, \tm{\pi_\li{1}}, \tm{\pi_\xt{\dag}}, \tm{\pi_\li{0}}, \tm{\pi_\li{1}}, \tm{\pi_\li{2}} \}$
\item specification\\
{\small$A_\calR := A_{00 \Rightarrow 21} \to A_{02 \Rightarrow 11} \to A_{0} \to 1 \to A_\smile \to (\bullet^\top \to \dag) \wedge (0^\top \to 1) \wedge (1^\top \to 0)$}
\begin{itemize}
\item rule application\\
$A_{ab \Rightarrow cd} :=
\big(0^\top \to c \to a \big) \wedge \big(1^\top \to d \to b \big) \wedge \bigwedge\limits_{e \in \{0, 1, 2\}} \big(\bullet^\top \to e \to e \big)$
\item initialization\\
$A_{0} := \big(\bullet^\top \to 0 \to 0 \big) \wedge \big(1^\top \to 0 \to 0 \big) \wedge \big(0^\top \to 0 \to 1 \big) \wedge \big(\bullet^\top \to 1 \to \dag \big)$
\item finalization $1$
\item expansion (find suitable word length)\\
$\arraycolsep=1.4pt\begin{array}{lcl}
A_\smile &:=& \big(\bullet^\top \to \big(\bullet^\top \to 0 \big) \to 0 \big) \wedge \big(1^\top \to \big(\bullet^\top \to 0 \big) \to 0 \big) \wedge\phantom{pain}\\
&&\big(0^\top \to \big(1^\top \to 0 \big) \to 1 \big) \wedge \big(\bullet^\top \to \big(\big(0^\top \to 1 \big) \wedge \big(\bullet^\top \to \dag \big)\big) \to \dag \big)
\end{array}$
\item starting configuration $(\bullet^\top \to \dag) \wedge (0^\top \to 1) \wedge (1^\top \to 0)$
\end{itemize}
%\item finite function $f_\calR \in \enc{A_\calR}$
%\begin{itemize}
%\item $\enc{a} = \{a\}$ for $a \in \calU$
%\item $\enc{A \to B} = \{f \mid \text{for all } a \in \enc{A} \text{ we have } f(a) \in \enc{B} \}$
%\item $\enc{A \wedge B} = \enc{A} \wedge \enc{B}$
%\end{itemize}
\end{itemize}

\begin{itemize}
%\item example $\calR  = \{\li{00} \Rightarrow \li{21}, \li{02} \Rightarrow \li{11}\}$
\item universe $\calU := \{\pi_\bot, \pi_\top, \pi_\bullet, \pi_\dag, \pi_0, \pi_1, \pi_2 \}$
\item each $M \in \calU$ of simple type $\sigma_{\calU} := \underbrace{\ga \to \cdots \to \ga}_{\scriptsize|\calU| \text{ times}} \to \ga$
\item specification\\
{\small$A_\calR := A_{00 \Rightarrow 21} \to A_{02 \Rightarrow 11} \to A_{0} \to 1 \to A_\smile \to (\bullet^\top \to \dag) \wedge (0^\top \to 1) \wedge (1^\top \to 0)$}
\end{itemize}
%\begin{definition}[Interpolation Equation]
%$\tm{x\,M_1 \ldots M_n} = \tm{M_{n+1}}$ where $\tm{M_1}, \ldots, \tm{M_{n+1}}$ are terms in normal form with no occurrence of $\tm{x}$.
%\end{definition}
\begin{enumerate}
\item semantic constraints (1), (2), (3)
\begin{itemize}
\item[(1)] $X\,G_{00 \Rightarrow 21}\,G_{02 \Rightarrow 11}\,G_{0}\,\pi_{1}\,G_\smile\,G^{\top}_{\bullet} =_\beta \pi_{\dag}$
\item[(2)] $X\,G_{00 \Rightarrow 21}\,G_{02 \Rightarrow 11}\,G_{0}\,\pi_{1}\,G_\smile\,G^{\top}_{0} =_\beta \pi_{1}$
\item[(3)] $X\,G_{00 \Rightarrow 21}\,G_{02 \Rightarrow 11}\,G_{0}\,\pi_{1}\,G_\smile\,G^{\top}_{1} =_\beta \pi_{0}$
\end{itemize}
\item syntactic constraints (4), (5)
\begin{itemize}
\item[(4)] $X\,H_{00 \Rightarrow 21}\,H_{02 \Rightarrow 11}\,H_{0}\,\pi_{1}\,H_\smile\,H^{\top}_{\bullet} =_\beta \pi_{\dag}$
\item[(5)] $X\,I\,I\,(\lambda h.\lambda x.x)\,u\,(\lambda h.\lambda g.g\,I)\,I =_\beta u$
\end{itemize}
\item combine constraints (1)--(5) to matching instance $\calM_\calR := (F\,X = N)$
\begin{itemize}
\item $F := \lambda x.\lambda y.y\hspace*{-0.3em} \begin{array}[t]{l}
(x\,G_{00 \Rightarrow 21}\,G_{02 \Rightarrow 11}\,G_{0}\,\pi_{1}\,G_\smile\,G^{\top}_{\bullet})\\
(x\,G_{00 \Rightarrow 21}\,G_{02 \Rightarrow 11}\,G_{0}\,\pi_{1}\,G_\smile\,G^{\top}_{0})\\
(x\,G_{00 \Rightarrow 21}\,G_{02 \Rightarrow 11}\,G_{0}\,\pi_{1}\,G_\smile\,G^{\top}_{1})\\
(x\,H_{00 \Rightarrow 21}\,H_{02 \Rightarrow 11}\,H_{0}\,\pi_{1}\,H_\smile\,H^{\top}_{\bullet})\\
(\lambda u.x\,I\,I\,(\lambda h.\lambda x.x)\,u\,(\lambda h.\lambda g.g\,I)\,I)
\end{array}$
%$\begin{array}{lcll}
%\tm{F} &=& \lambda x.\lambda y.y & \big(da
%\end{array}$
\item $N := \lambda y.y\,\pi_{\dag}\,\pi_{1}\,\pi_{0}\,\pi_{\dag}\,(\lambda u.u)$
\end{itemize}
\end{enumerate}

\begin{theorem}
Given a simple semi-Thue system $\calR$, the matching instance $\calM_\calR$ is solvable iff for some $n > 0$ we have $0^n \Rightarrow^*_\calR 1^n$.
\end{theorem}

\begin{proof}[Proof Outline]
\vspace*{-0.2em}
\begin{itemize}
\item[$\Rightarrow$:] Induction on solution term size, using case analysis.
\item[$\Leftarrow$:] Induction on the number of rewrite steps.\qedhere
\end{itemize}
\end{proof}

\begin{corollary}
Higher-order $\beta$-matching is undecidable.
\end{corollary}

\begin{remark}
\begin{description}
\item[($30$ LOC)] problem definition (\lstinline$HOMbeta$)
\item[($1000$ LOC)] simply typed $\lambda$-calculus infrastructure (\lstinline$autosubst$, confluence, normalization) 
\item[($3000$ LOC)] many-one reduction from $0^+ \Rightarrow^*_\calR 1^+$ to \lstinline$HOMbeta$
\item[($4$s)] compilation time (heavy use of \lstinline$ssreflect$, \lstinline$lia$, \lstinline$auto$)
\end{description}
\end{remark}

\begin{itemize}
%\item universe elements $\tm{\pi_i} : \ity{\ga \to \cdots \to \ga \to \ga}$ of order $2$
\item $\beta$-matching is undecidable at order $6$~[\cite{Loader03}]
\begin{itemize}
\item $\lambda$-definability is undecidable at order $4$~[\cite{loader2001undecidability}]
\item $(7+1)$-lifts increase order by $2$
\end{itemize}
\item present work: $\beta$-matching at order $6$
\begin{itemize}
\item $A_\calR$ of order $5$
\item universe elements $\pi_i$ increase order by $1$
\end{itemize}
\item $\eta$-long $\beta$-matching is decidable at order $4$~[\cite{Padovani00}]
\item $\eta$-long $\beta$-matching is equivalent to $\beta\eta$-matching~[\cite{Stovring06}]
%\begin{itemize}
%\item translates to $\beta\eta$-matching at order $4$
%\item does decidability translate to $\beta$-matching at order $4$?
%\end{itemize}
\end{itemize}

\bigskip

\large
\enquote{\textit{one might guess that undecidability starts at order $5$}}~[\cite{Loader03}]
\normalsize

\bigskip

\begin{itemize}
\item undecidability at order $5$ using Loader's approach?
\begin{itemize}
\item remove $1$-lifts? (so far, I failed)
\end{itemize}
\item undecidability at order $5$ using present approach?
\begin{itemize}
\item intersection type inhabitation is undecidable at order $4$
\item universe elements $\pi_i$ increase order by $1$
\item specification argument $\top$ facilitates syntactic constraints
\item remove $\top$? (so far, I failed)
\end{itemize}
%\item undecidability at order $5$ using different approach?
%\begin{itemize}
%\item Hilbert's 10th problem as starting point
%\end{itemize}
\end{itemize}

\begin{example}
\begin{itemize}
\item specification $A := \big((1 \to 2) \wedge (2 \to 3) \wedge (3 \to 1)\big) \to 1 \to 3$
\item universe elements $\pi_1, \pi_2, \pi_3$
\item permutation $G$ realizing $(1 \to 2) \wedge (2 \to 3) \wedge (3 \to 1)$
\item \emph{semantic} constraint (1) $X\,G\,\pi_1 =_{\beta\eta} \pi_3$
\item \emph{syntactic} constraint (2) $X\,I\,u =_{\beta\eta} u$
\item troubling solution $X \mapsto \lambda g.\lambda h.\lambda xyz.h\,(g\,\pi_1 x\,z\,y)\,y\,z$
\begin{itemize}
\item[(1)] $\arraycolsep=1.4pt\begin{array}[t]{lll}
X\,G\,\pi_1 &\mapsto& \big(\lambda g.\lambda h.\lambda xyz.h\,(g\,\pi_1 x\,z\,y)\,y\,z\big)\,G\,\pi_1\\
&\twoheadrightarrow_\beta& \lambda xyz.\pi_{1}\,(G\,\pi_1 x\,z\,y)\,y\,z\\
&\twoheadrightarrow_\beta& \lambda xyz.\pi_2\,x\,z\,y \twoheadrightarrow_\beta \lambda xyz.z = \pi_{3}
\end{array}$
\item[(2)] $\arraycolsep=1.4pt\begin{array}[t]{lll}
X\,I\,u &\mapsto& \big(\lambda g.\lambda h.\lambda xyz.h\,(g\,\pi_1 x\,z\,y)\,y\,z\big)\,I\,u\\
&\twoheadrightarrow_\beta& \lambda xyz.u\,(I\,\pi_1 x\,z\,y)\,y\,z\\
&\twoheadrightarrow_\beta& \lambda xyz.u\,(\pi_1 x\,z\,y)\,y\,z \twoheadrightarrow_\beta \lambda xyz.u\,x\,y\,z =_\eta u
\end{array}$
\end{itemize}
\end{itemize}
\end{example}

\section{Introduction}

We like to reduce the problem $\exists n.\0^{n+1} \twoheadrightarrow \1^{1+n}$ for simple semi-Thue systems to higher-order matching.
A simple semi-Thue system $\calR = \{R_1, \ldots R_k\}$ over an alphabet $\Sigma \supseteq \{\0, \1\}$ contains rules of shape $ab \mapsto cd$.

For the following intersection types we have that the problem $\exists n.\0^{n+1} \twoheadrightarrow \1^{1+n}$ corresponds to the type inhabitation problem $\vdash\,?: \sigma_\star \to \sigma_\0 \to \sigma_{R_1} \to \cdots \sigma_{R_k} \to \sigma_\1 \to \$$.

\begin{align*}
\sigma_\star & := \Big(\big((\top \to \bullet) \to *\big) \to * \Big) \cap
\Big(\big((\top \to \RIGHTcircle) \to *\big) \to \# \Big) \cap
\bigg(\Big(\big((\top \to \LEFTcircle) \to \#\big) \cap \big((\top \to \bullet) \to \$ \big)\Big) \to \$ \bigg)\\
\sigma_0 & := \big(\0 \to (\top \to \bullet) \to * \big) \cap \big(\0 \to (\top \to \RIGHTcircle) \to * \big) \cap \big(\0 \to (\top \to \LEFTcircle) \to \# \big) \cap \big(\1 \to (\top \to \bullet) \to \$ \big)\\
\sigma_{ab \to cd} & := \big(c \to (\top \to \LEFTcircle) \to a \big) \cap \big(d \to (\top \to \RIGHTcircle) \to b \big) \cap \bigcap_{e \in \Sigma} \big(e \to (\top \to \bullet) \to e \big)\\
\sigma_1 & := \1
\end{align*}

\begin{remark}
The functions corresponding to $\sigma_\star, \sigma_\0, \sigma_{R_1}, \ldots, \sigma_{R_k}, \sigma_\1$ are realizable in the domain $D = \{\bullet, *, \LEFTcircle, \RIGHTcircle, \#, \$, \top, \bot\} \,\dot{\cup}\, \Sigma$.
\end{remark}

Intuition:
\begin{itemize}
\item $\sigma_\star$ expands a tape $* \ldots * \#\$$ and saves adjacency information.
\item $\sigma_\0$ initializes the tape to $\0 \ldots \0 \1$.
\item $\sigma_{ab \to cd}$ performs rewriting operations.
\item $\sigma_\1$ accepts the tape $\1 \ldots \1$.
\end{itemize}

\newpage

Let $\Sigma = \{e_1, \ldots, e_m\}$, $D := \{\bullet, *, \LEFTcircle, \RIGHTcircle, \#, \$, \top, \bot\} \,\dot{\cup}\, \Sigma$ and $n := |D| = 8 + m$ in the remainder of the presentation.
Let us assign unique values $1 \ldots n$ to individual symbols in $D$, where $\bot$ is assigned the value $n$.
We freely write $x$ instead of its assigned value.
For example, if $x \in D$ is assigned the value $i$ we write $r_x$ for $r_i$, and we write $\pi_x$ for $\lambda r_1 \ldots r_n.r_i$.


Fix the following simple type $A := \underbrace{0 \to \cdots 0 \to}_{n \text{ times}} 0$.

\[
\caseelse{x}{i_1 \mapsto t_1 \mid \ldots \mid i_k \mapsto t_k}{t} := (x\,u_1 \ldots u_n) \text{ where } u_i = \begin{cases} t_j & \text{if } i = i_j\\t & \text{otherwise}\end{cases}
\]

We may omit the \textbf{else} branch if it is the most recently bound variable, that is

\[\Big(\lambda r_1 \ldots r_n.\case{x}{i_1 \mapsto t_1 \mid \ldots \mid i_k \mapsto t_k}\Big) := \Big(\lambda r_1 \ldots r_n.\caseelse{x}{i_1 \mapsto t_1 \mid \ldots \mid i_k \mapsto t_k}{r_n}\Big)\]

If we only have one case and the \textbf{else} branch is the most recently bound variable we write

\[\Big(\lambda r_1 \ldots r_n.\itb{x}{i}{s}\Big) := \Big(\lambda r_1 \ldots r_n.\caseelse{x}{i \mapsto s}{r_n}\Big)\]

\newpage

\section{Shape Control}

consider the specification $\rho_{R_1} \to \cdots \to \rho_{R_k} \to \rho_0 \to \rho_1 \to \rho_\star \to \rho_\bullet \to \$$ where

\begin{align*}
\rho_\bullet & := \top \to \bullet \\
\rho_\star & := \rho_\bullet \to \Big(\rho_\bullet \to \$ \Big) \to \$\\
\rho_0 & := \rho_\bullet \to \1 \to \$\\
\rho_{ab \to cd} & := \rho_\bullet \to \1 \to \1\\
\rho_1 & := \1
\end{align*}

Inhabitants are necessary of shape $\lambda x_{R_1} \ldots x_{R_k} \, x_0 \, x_1 \, x_\star \, x_\bullet.M$ where $M$ is TODO

\begin{align*}
\delta^\top_i := & \lambda x.\lambda s_1 \ldots s_n.\itb{x}{\top}{s_i}\\\\
F_\star := &\lambda h^{A \to A}.g^{(A \to A) \to A}.g\,(\lambda x^A.x)\\
F_\0 := &\lambda h^{A \to A}.\lambda x^A.x\\
F_{ab \to cd} := &\lambda h^{A \to A}.h\\\\
H_\star := &\lambda h^{A \to A}.\lambda g^{(A \to A) \to A}.\lambda r_1 \ldots r_n. \itb{g\,\delta^\top_\bullet}{\$}{r_\$}\\
H_\0 := &\lambda h^{A \to A}.\lambda x^A. \lambda r_1 \ldots r_n.\itb{x}{\1}{r_\$}\\
H_{ab \to cd} := &\lambda h^{A \to A}.\lambda x^A. \lambda r_1 \ldots r_n.\itb{h\,\pi_\top}{{\bullet}}{(\itb{x}{\1}{r_\1})}\\
H_\1 := &\pi_\1
\end{align*}

Consider the higher-order matching problem

\begin{align*}
&X\,F_{R_1} \ldots F_{R_k}\,F_\0\,z\,F_\star\,I = z\\
&X\,H_{R_1} \ldots H_{R_k}\,H_\0\,H_\1\,H_\star\,\delta^\top_\bullet = \pi_\$
\end{align*}

for this the following constraint must be solved

\[\Big(\lambda x.\lambda y.y\,(\lambda z.x\,F_{R_1} \ldots F_{R_k}\,F_\0\,z\,F_\star\,I) (x\,H_{R_1} \ldots H_{R_k}\,H_\0\,H_\1\,H_\star\,\delta^\top_\bullet)\Big)\,X = \lambda y.y\,(\lambda z.z)\,\pi_\$\]

Solutions to this constraint have a specific shape which can be used for semantics.
The last $\delta^\top_\bullet$ is used for the first positional abstraction.

\newpage

\section{Semantics}

We mimic intersection type inhabitation using the following higher-order matching problem

\begin{align*}
&X\,G_{R_1} \ldots G_{R_k}\,G_\0\,G_\1\,G_\star\,\delta_\bullet = \pi_\$\\
&X\,G_{R_1} \ldots G_{R_k}\,G_\0\,G_\1\,G_\star\,\delta_{\LEFTcircle} = \pi_\#\\
&X\,G_{R_1} \ldots G_{R_k}\,G_\0\,G_\1\,G_\star\,\delta_{\RIGHTcircle} = \pi_*
\end{align*}
where
\begin{align*}
G_\star := &\lambda h^{A \to A}.\lambda g^{(A \to A) \to A}.\lambda r_1 \ldots r_n.\case{h\,\pi_\top}{\\
&\hspace{1.8em} \bullet \mapsto \case{g\,\delta^\top_\bullet}{* \mapsto r_* \mid \$ \mapsto \itb{g\,\delta^\top_{\LEFTcircle}}{\#}{r_\$}}\\
&\hspace{1.8em} \RIGHTcircle \mapsto \case{g\,\delta^\top_\bullet}{* \mapsto r_*}\\
&\hspace{1.8em} \LEFTcircle \mapsto \case{g\,\delta^\top_{\RIGHTcircle}}{* \mapsto r_\#}}\\
%&\quad\mid \$ \mapsto \caseelse{g\,\delta^\top_{\LEFTcircle}}{\# \mapsto r_\$}{r_\bot}}{\\
%&\quad \caseelse{g\,\delta^\top_{\RIGHTcircle}}{* \mapsto r_\#}{r_\bot}}\\
%&\caseelse{g\,\delta^\top_\bullet}{\\
%&\hspace{1.8em} * \mapsto r_*\\
%&\quad\mid \$ \mapsto \caseelse{g\,\delta^\top_{\LEFTcircle}}{\# \mapsto r_\$}{r_\bot}}{\\
%&\quad \caseelse{g\,\delta^\top_{\RIGHTcircle}}{* \mapsto r_\#}{r_\bot}}\\
G_\0 := &\lambda h^{A \to A}.\lambda x^A. \lambda r_1 \ldots r_n.\case{h\,\pi_\top}{\\
&\hspace{1.8em}\bullet \mapsto \case{x}{\0 \mapsto r_* \mid \1 \mapsto r_\$}\\
&\quad\mid\RIGHTcircle \mapsto \case{x}{\0 \mapsto r_*}\\
&\quad\mid\LEFTcircle \mapsto \case{x}{\0 \mapsto r_\# }}\\
G_{ab \to cd} := &\lambda h^{A \to A}.\lambda x^A.\lambda r_1 \ldots r_n.\case{h\,\pi_\top}{\\
&\hspace{1.8em}\bullet \mapsto x\,r_1 \ldots r_n\\
&\quad\mid\RIGHTcircle \mapsto \case{x}{d \mapsto r_b}\\
&\quad\mid\LEFTcircle \mapsto \case{x}{c \mapsto r_a }}\\
G_\1 := &\pi_\1
\end{align*}
recalling
\begin{align*}
\sigma_\star := & \Big((\top \to \bullet) \to \big((\top \to \bullet) \to *\big) \to * \Big) \cap \\
&\Big((\top \to \RIGHTcircle) \to \big((\top \to \bullet) \to *\big) \to * \Big) \cap \\
& \Big((\top \to \LEFTcircle) \to \big((\top \to \RIGHTcircle) \to *\big) \to \# \Big) \cap \\
& \bigg((\top \to \bullet) \to \Big(\big((\top \to \LEFTcircle) \to \#\big) \cap \big((\top \to \bullet) \to \$ \big)\Big) \to \$ \bigg)\\
\sigma_0 := &\big((\top \to \bullet) \to \0 \to * \big) \cap \big((\top \to \RIGHTcircle) \to \0 \to * \big) \cap \big((\top \to \LEFTcircle) \to \0 \to \# \big) \cap \big((\top \to \bullet) \to \1 \to \$ \big)\\
\sigma_{ab \to cd} := &\big((\top \to \LEFTcircle) \to c \to a \big) \cap \big((\top \to \RIGHTcircle) \to d \to b \big) \cap \bigcap_{e \in \Sigma} \big((\top \to \bullet) \to e \to e \big)\\
\sigma_1 := &\1
\end{align*}
all constraints are combined into the following matching problem over the variable $X$
\begin{align*}
\Big(\lambda x. \lambda y.y\,&(\lambda z.x\,F_{R_1} \ldots F_{R_k}\,F_\0\,z\,F_\star\,I)\\
&(x\,H_{R_1} \ldots H_{R_k}\,H_\0\,H_\1\,F_\star\,\delta_\bullet)\\
&(x\,G_{R_1} \ldots G_{R_k}\,G_\0\,G_\1\,G_\star\,\delta_\bullet)\\
&(x\,G_{R_1} \ldots G_{R_k}\,G_\0\,G_\1\,G_\star\,\delta_{\LEFTcircle})\\
&(x\,G_{R_1} \ldots G_{R_k}\,G_\0\,G_\1\,G_\star\,\delta_{\RIGHTcircle})\Big)\,X = \lambda y.y\,I\,\pi_\$\,\pi_\$\,\pi_\#\,\pi_*\\
\end{align*}

Remarks
\begin{itemize}
\item For inhabitation instead of $\top \to \LEFTcircle$ just the type $\LEFTcircle$ suffices, whereas for matching it is required for structural constraints (equation 1).
\end{itemize}

\section{Undecidability of Rank 3 Intersection Type Inhabitation}

Given a simple semi-Thue system $\calR$
\begin{enumerate}
\item construct intersection type $A_\calR$
\begin{itemize}
\item $A_\calR$ is inhabited iff $0^+ \Rightarrow^*_\calR 1^+$
\end{itemize}
\end{enumerate}

\bigskip

\begin{remark}[Properties of $A_\calR$]
\begin{itemize}
\item based on~[\cite{Urzyczyn09}] and~[\cite{DudenhefnerR19}]
\item has rank 3
\item allows for simple tools (no $\lambda\bot$-terms or myopic order)
\item $\lambda$-definable when interpreted as finite function~[\cite{SalvatiMGB12}]
\end{itemize}
\end{remark}

\begin{theorem}
Given a simple semi-Thue system $\calR$, the intersection type $A_\calR$ is inhabited iff for some $n > 0$ we have $0^n \Rightarrow^*_\calR 1^n$.
\end{theorem}

\begin{proof}[Proof Outline~{[\cite{DudenhefnerR19}]}]
\vspace*{-0.2em}
\begin{itemize}
\item[$\Rightarrow$:] Induction on inhabitant size, using generation lemma.
\item[$\Leftarrow$:] Induction on the number of rewrite steps.\qedhere
\end{itemize}
\end{proof}

\begin{corollary}
Intersection type inhabitation is undecidable.
\end{corollary}

\newpage

\bibliography{bibliography}

\end{document}
