\section{Mechanization}\label{sec:mech}

This section provides a brief overview over the mechanization of undecidability of higher-order $\beta$-matching (Theorem~\ref{thm:hom_undec}) using the Coq proof assistant~\cite{Coq_2023}.
The mechanization is axiom-free and spans approximately $4000$ lines of code, consisting of the following parts:
\begin{itemize}
\item \texttt{HOMatching.v} contains definitions of the simply typed $\lambda$-calculus~\coqextra{LambdaCalculus/HOMatching.v\#L31} and higher-order $\beta$-matching~\coqextra{LambdaCalculus/HOMatching.v\#L37}.
\item \texttt{Util/stlc\_facts.v} and \texttt{Util/term\_facts.v} contain basic properties of the simply typed $\lambda$-calculus, such as confluence of $\beta$-reduction~\coqextra{LambdaCalculus/Util/term\_facts.v\#L1056}, substitution lemmas~\coqextra{LambdaCalculus/Util/stlc\_facts.v\#L100}, and type preservation properties~\coqextra{LambdaCalculus/Util/stlc\_facts.v\#L116}.
\item \texttt{Reductions/SSTS01\_to\_HOMbeta.v} contains the reduction from Problem $\0^+ \Rightarrow^* \1^+$ to higher-order $\beta$-matching~\coq{L2880}.
\item \texttt{HOMatching\_undec.v} contains the undecidability result for higher-order $\beta$-matching~\coqextra{LambdaCalculus/HOMatching\_undec.v\#L16}.
\end{itemize}

The simple type system \texttt{stlc} is mechanized in \texttt{HOMatching.v}, borrowing the existing term definitions from the library~\coqextra{L/L.v\#L8}, for which variable binding is addressed via the unscoped de Bruijn approach~\cite{deBruijn72}.
The proposition \texttt{stlc~Gamma~M~t} mechanizes that the term \texttt{M} is assigned the simple type~\texttt{t} in the simple type environment \texttt{Gamma}.
\begin{lstlisting}[mathescape]
Inductive ty : Type :=
  | atom (* type variable *)
  | arr (s t : ty). (* function type *)

Inductive term : Type :=
  | var (n : nat) : term (* term variable *)
  | app (s : term) (t : term) : term (* application *)
  | lam (s : term). (* abstraction *)

Inductive stlc (Gamma : list ty) : term -> ty -> Prop :=
  | stlc_var x t : nth_error Gamma x = Some t ->
      stlc Gamma (var x) t (* variable rule *)
  | stlc_app M N s t : stlc Gamma M (arr s t) -> stlc Gamma N s ->
      stlc Gamma (app M N) t (* application rule *)
  | stlc_lam M s t : stlc (cons s Gamma) M t ->
      stlc Gamma (lam M) (arr s t). (* abstraction rule *)
\end{lstlisting}

Higher-order $\beta$-matching is mechanized as the predicate \texttt{HOMbeta}: given terms \texttt{F} of type \texttt{arr s t} and \texttt{N} of type \texttt{t}, is there a simply typed term \texttt{M} of type \texttt{s} such that \texttt{app F M} is $\beta$-equivalent (reflexive, symmetric, transitive closure of \texttt{step}) to \texttt{N}?
\begin{lstlisting}[mathescape]
Definition HOMbeta : { '(s, t, F, N) : (ty * ty * term * term) 
  | stlc nil F (arr s t) /\ stlc nil N t } -> Prop :=
    fun '(exist _ (s, t, F, N) _) =>
      exists (M : term), stlc nil M s /\
 clos_refl_sym_trans term step (app F M) N.
\end{lstlisting}

The proposition \lstinline|undecidable HOMbeta|~\coqextra{LambdaCalculus/HOMatching\_undec.v\#L16} mechanizes the undecidability of the predicate \texttt{HOMbeta}, relying on the following library definition~\cite[Chapter~19]{forster2021computability}.
A predicate \texttt{p} is undecidable, if existence of a computable decider for \texttt{p} implies recursive co-enumerability of the (Turing machine) Halting Problem.
\begin{lstlisting}[mathescape]
Definition undecidable {X} (p : X -> Prop) :=
 decidable p -> enumerable (complement SBTM_HALT).
\end{lstlisting}
Since the Halting Problem is recursively enumerable, decidability of \texttt{p} would imply decidability of the Halting Problem.